import {
  invariant
} from "./chunk-XUSVWCLU.js";
import {
  AbstractConnector
} from "./chunk-IGENY7QT.js";
import {
  require_events
} from "./chunk-E4YFJ4DO.js";
import "./chunk-LPPLLAJT.js";
import {
  __commonJS,
  __toESM
} from "./chunk-IKJM6GHQ.js";

// node_modules/eth-provider/resolve/index.js
var require_resolve = __commonJS({
  "node_modules/eth-provider/resolve/index.js"(exports, module) {
    var getProtocol = (location) => {
      if (location === "injected")
        return "injected";
      if (location.endsWith(".ipc"))
        return "ipc";
      if (location.startsWith("wss://") || location.startsWith("ws://"))
        return "ws";
      if (location.startsWith("https://") || location.startsWith("http://"))
        return "http";
      return "";
    };
    module.exports = (targets, presets) => {
      return [].concat(...[].concat(targets).map((provider) => {
        if (presets[provider]) {
          return presets[provider].map((location) => ({ type: provider, location, protocol: getProtocol(location) }));
        } else {
          return { type: "custom", location: provider, protocol: getProtocol(provider) };
        }
      })).filter((provider) => {
        if (provider.protocol || provider.type === "injected") {
          return true;
        } else {
          console.log('eth-provider | Invalid provider preset/location: "' + provider.location + '"');
          return false;
        }
      });
    };
  }
});

// node_modules/ethereum-provider/index.js
var require_ethereum_provider = __commonJS({
  "node_modules/ethereum-provider/index.js"(exports, module) {
    var EventEmitter = require_events();
    var EthereumProvider = class extends EventEmitter {
      constructor(connection) {
        super();
        this.connected = false;
        this.nextId = 0;
        this.promises = {};
        this.subscriptions = [];
        this.connection = connection;
        this.connection.on("connect", () => this.checkConnection());
        this.connection.on("close", () => this.emit("close"));
        this.connection.on("payload", (payload) => {
          const { id, method, error, result } = payload;
          if (typeof id !== "undefined") {
            if (this.promises[id]) {
              payload.error ? this.promises[id].reject(error) : this.promises[id].resolve(result);
              delete this.promises[id];
            }
          } else if (method && method.indexOf("_subscription") > -1) {
            this.emit(payload.params.subscription, payload.params.result);
            this.emit(method, payload.params);
            this.emit("data", payload);
          }
        });
        this.on("newListener", (event, listener) => {
          if (event === "networkChanged") {
            if (!this.attemptedNetworkSubscription && this.connected)
              this.startNetworkSubscription();
          } else if (event === "accountsChanged") {
            if (!this.attemptedAccountsSubscription && this.connected)
              this.startAccountsSubscription();
          }
        });
      }
      async checkConnection() {
        try {
          this.emit("connect", await this._send("net_version"));
          this.connected = true;
          if (this.listenerCount("networkChanged") && !this.attemptedNetworkSubscription)
            this.startNetworkSubscription();
          if (this.listenerCount("accountsChanged") && !this.attemptedAccountsSubscription)
            this.startAccountsSubscription();
        } catch (e) {
          this.connected = false;
        }
      }
      async startNetworkSubscription() {
        this.attemptedNetworkSubscription = true;
        try {
          let networkChanged = await this.subscribe("eth_subscribe", "networkChanged");
          this.on(networkChanged, (netId) => this.emit("networkChanged", netId));
        } catch (e) {
          console.warn("Unable to subscribe to networkChanged", e);
        }
      }
      async startAccountsSubscription() {
        this.attemptedAccountsSubscription = true;
        try {
          let accountsChanged = await this.subscribe("eth_subscribe", "accountsChanged");
          this.on(accountsChanged, (accounts) => this.emit("accountsChanged", accounts));
        } catch (e) {
          console.warn("Unable to subscribe to accountsChanged", e);
        }
      }
      enable() {
        return new Promise((resolve, reject) => {
          this._send("eth_accounts").then((accounts) => {
            if (accounts.length > 0) {
              this.accounts = accounts;
              this.coinbase = accounts[0];
              this.emit("enable");
              resolve(accounts);
            } else {
              const err = new Error("User Denied Full Provider");
              err.code = 4001;
              reject(err);
            }
          }).catch(reject);
        });
      }
      _send(method, params = []) {
        if (!method || typeof method !== "string")
          return new Error("Method is not a valid string.");
        if (!(params instanceof Array))
          return new Error("Params is not a valid array.");
        const payload = { jsonrpc: "2.0", id: this.nextId++, method, params };
        const promise = new Promise((resolve, reject) => {
          this.promises[payload.id] = { resolve, reject };
        });
        this.connection.send(payload);
        return promise;
      }
      send(...args) {
        return this._send(...args);
      }
      _sendBatch(requests) {
        return Promise.all(requests.map((payload) => this._send(payload.method, payload.params)));
      }
      subscribe(type, method, params = []) {
        return this._send(type, [method, ...params]).then((id) => {
          this.subscriptions.push(id);
          return id;
        });
      }
      unsubscribe(type, id) {
        return this._send(type, [id]).then((success) => {
          if (success) {
            this.subscriptions = this.subscriptions.filter((_id) => _id !== id);
            this.removeAllListeners(id);
            return success;
          }
        });
      }
      sendAsync(payload, cb) {
        if (!cb || typeof cb !== "function")
          return cb(new Error("Invalid or undefined callback provided to sendAsync"));
        if (!payload)
          return cb(new Error("Invalid Payload"));
        if (payload instanceof Array) {
          return this.sendAsyncBatch(payload, cb);
        } else {
          return this._send(payload.method, payload.params).then((result) => {
            cb(null, { id: payload.id, jsonrpc: payload.jsonrpc, result });
          }).catch((err) => {
            cb(err);
          });
        }
      }
      sendAsyncBatch(payload, cb) {
        return this._sendBatch(payload).then((results) => {
          let result = results.map((entry, index) => {
            return { id: payload[index].id, jsonrpc: payload[index].jsonrpc, result: entry };
          });
          cb(null, result);
        }).catch((err) => {
          cb(err);
        });
      }
      isConnected() {
        return this.connected;
      }
      close() {
        this.connection.close();
        this.connected = false;
        let error = new Error(`Provider closed, subscription lost, please subscribe again.`);
        this.subscriptions.forEach((id) => this.emit(id, error));
        this.subscriptions = [];
      }
    };
    module.exports = EthereumProvider;
  }
});

// node_modules/eth-provider/ConnectionManager/index.js
var require_ConnectionManager = __commonJS({
  "node_modules/eth-provider/ConnectionManager/index.js"(exports, module) {
    var EventEmitter = require_events();
    var dev = true;
    var ConnectionManager = class extends EventEmitter {
      constructor(connections, targets, options) {
        super();
        this.targets = targets;
        this.connections = connections;
        this.connected = false;
        this.status = "loading";
        this.interval = options.interval || 5e3;
        this.name = options.name || "default";
        this.inSetup = true;
        this.connect();
      }
      connect(index = 0) {
        if (dev && index === 0)
          console.log(`



A connection cycle started for provider with name: ${this.name}`);
        if (this.connection && this.connection.status === "connected" && index >= this.connection.index) {
          if (dev)
            console.log("Stopping connection cycle becasuse we're already connected to a higher priority provider");
        } else if (this.targets.length === 0) {
          if (dev)
            console.log("No valid targets supplied");
        } else {
          const { protocol, location } = this.targets[index];
          this.connection = this.connections[protocol](location);
          this.connection.on("error", (err) => {
            if (!this.connected)
              return this.connectionError(index, err);
            if (this.listenerCount("error"))
              return this.emit("error", err);
            console.warn("eth-provider - Uncaught connection error: " + err.message);
          });
          this.connection.on("close", (summary) => {
            this.connected = false;
            this.emit("close");
            if (!this.closing)
              this.refresh();
          });
          this.connection.on("connect", () => {
            this.connection.target = this.targets[index];
            this.connection.index = index;
            this.targets[index].status = this.connection.status;
            this.connected = true;
            this.inSetup = false;
            if (dev)
              console.log("Successfully connected to: " + this.targets[index].location);
            this.emit("connect");
          });
          this.connection.on("data", (data) => this.emit("data", data));
          this.connection.on("payload", (payload) => this.emit("payload", payload));
        }
      }
      refresh(interval = this.interval) {
        if (dev)
          console.log(`Reconnect queued for ${(interval / 1e3).toFixed(2)}s in the future`);
        clearTimeout(this.connectTimer);
        this.connectTimer = setTimeout(() => this.connect(), interval);
      }
      connectionError(index, err) {
        this.targets[index].status = err;
        if (this.targets.length - 1 === index) {
          this.inSetup = false;
          if (dev)
            console.warn("eth-provider unable to connect to any targets, view connection cycle summary: ", this.targets);
          this.refresh();
        } else {
          this.connect(++index);
        }
      }
      close() {
        this.closing = true;
        if (this.connection) {
          this.connection.close();
        } else {
          this.emit("close");
        }
        clearTimeout(this.connectTimer);
      }
      error(payload, message, code = -1) {
        this.emit("payload", { id: payload.id, jsonrpc: payload.jsonrpc, error: { message, code } });
      }
      send(payload) {
        if (this.inSetup) {
          setTimeout(() => this.send(payload), 100);
        } else if (this.connection.closed) {
          this.error(payload, "Not connected");
        } else {
          this.connection.send(payload);
        }
      }
    };
    module.exports = ConnectionManager;
  }
});

// node_modules/eth-provider/provider/index.js
var require_provider = __commonJS({
  "node_modules/eth-provider/provider/index.js"(exports, module) {
    var EventEmitter = require_events();
    var EthereumProvider = require_ethereum_provider();
    var ConnectionManager = require_ConnectionManager();
    var monitor = (provider) => {
      function update(status) {
        provider.status = status;
        if (provider instanceof EventEmitter)
          provider.emit("status", status);
      }
      async function check() {
        if (provider.inSetup)
          return setTimeout(check, 1e3);
        try {
          if (await provider.send("eth_syncing")) {
            update("syncing");
            setTimeout(() => check(), 5e3);
          } else {
            update("connected");
          }
        } catch (e) {
          update("disconnected");
        }
      }
      update("loading");
      check();
      provider.on("connect", () => check());
      provider.on("close", () => update("disconnected"));
      return provider;
    };
    module.exports = (connections, targets, options) => {
      if (connections.injected.__isProvider && targets.map((t) => t.type).indexOf("injected") > -1) {
        delete connections.injected.__isProvider;
        return monitor(connections.injected);
      }
      const provider = new EthereumProvider(new ConnectionManager(connections, targets, options));
      provider.setMaxListeners(128);
      return monitor(provider);
    };
  }
});

// node_modules/eth-provider/presets/index.js
var require_presets = __commonJS({
  "node_modules/eth-provider/presets/index.js"(exports, module) {
    module.exports = {
      injected: ["injected"],
      frame: ["ws://127.0.0.1:1248", "http://127.0.0.1:1248"],
      direct: ["ws://127.0.0.1:8546", "http://127.0.0.1:8545"],
      infura: ["wss://mainnet.infura.io/ws/v3/786ade30f36244469480aa5c2bf0743b", "https://mainnet.infura.io/v3/786ade30f36244469480aa5c2bf0743b"],
      infuraRopsten: ["wss://ropsten.infura.io/ws/v3/786ade30f36244469480aa5c2bf0743b", "https://ropsten.infura.io/v3/786ade30f36244469480aa5c2bf0743b"],
      infuraRinkeby: ["wss://rinkeby.infura.io/ws/v3/786ade30f36244469480aa5c2bf0743b", "https://rinkeby.infura.io/v3/786ade30f36244469480aa5c2bf0743b"],
      infuraKovan: ["wss://kovan.infura.io/ws/v3/786ade30f36244469480aa5c2bf0743b", "https://kovan.infura.io/v3/786ade30f36244469480aa5c2bf0743b"]
    };
  }
});

// node_modules/eth-provider/connections/injected.js
var require_injected = __commonJS({
  "node_modules/eth-provider/connections/injected.js"(exports, module) {
    var EventEmitter = require_events();
    var InjectedConnection = class extends EventEmitter {
      constructor(_injected, options) {
        super();
        if (_injected) {
          setTimeout(() => this.emit("error", new Error("Injected web3 provider is not currently supported")), 0);
        } else {
          setTimeout(() => this.emit("error", new Error("No injected provider found")), 0);
        }
      }
    };
    module.exports = (injected) => (options) => new InjectedConnection(injected, options);
  }
});

// node_modules/eth-provider/connections/unavailable.js
var require_unavailable = __commonJS({
  "node_modules/eth-provider/connections/unavailable.js"(exports, module) {
    var EventEmitter = require_events();
    var UnavailableConnection = class extends EventEmitter {
      constructor(message) {
        super();
        setTimeout(() => this.emit("error", new Error(message)), 0);
      }
    };
    module.exports = (message) => () => new UnavailableConnection(message);
  }
});

// node_modules/eth-provider/parse/index.js
var require_parse = __commonJS({
  "node_modules/eth-provider/parse/index.js"(exports, module) {
    var last;
    var timeout;
    module.exports = (res, cb) => {
      const values = [];
      res.replace(/\}[\n\r]?\{/g, "}|--|{").replace(/\}\][\n\r]?\[\{/g, "}]|--|[{").replace(/\}[\n\r]?\[\{/g, "}|--|[{").replace(/\}\][\n\r]?\{/g, "}]|--|{").split("|--|").forEach((data) => {
        if (last)
          data = last + data;
        let result;
        try {
          result = JSON.parse(data);
        } catch (e) {
          last = data;
          clearTimeout(timeout);
          timeout = setTimeout(() => cb(new Error("Parse response timeout")), 15 * 1e3);
          return;
        }
        clearTimeout(timeout);
        last = null;
        if (result)
          values.push(result);
      });
      cb(null, values);
    };
  }
});

// node_modules/eth-provider/connections/ws.js
var require_ws = __commonJS({
  "node_modules/eth-provider/connections/ws.js"(exports, module) {
    var EventEmitter = require_events();
    var parse = require_parse();
    var dev = true;
    var WebSocket;
    var WebSocketConnection = class extends EventEmitter {
      constructor(_WebSocket, url, options) {
        super();
        WebSocket = _WebSocket;
        setTimeout(() => this.create(url, options), 0);
      }
      create(url, options) {
        if (!WebSocket)
          this.emit("error", new Error("No WebSocket transport available"));
        try {
          this.socket = new WebSocket(url);
        } catch (e) {
          return this.emit("error", e);
        }
        this.socket.addEventListener("error", (err) => this.emit("error", err));
        this.socket.addEventListener("open", () => {
          this.emit("connect");
          this.socket.addEventListener("message", (message) => {
            const data = typeof message.data === "string" ? message.data : "";
            parse(data, (err, payloads) => {
              if (err)
                return;
              payloads.forEach((load) => {
                if (Array.isArray(load)) {
                  load.forEach((payload) => this.emit("payload", payload));
                } else {
                  this.emit("payload", load);
                }
              });
            });
          });
          this.socket.addEventListener("close", () => this.onClose());
        });
      }
      onClose() {
        this.socket = null;
        this.closed = true;
        if (dev)
          console.log("Closing WebSocket connection");
        this.emit("close");
        this.removeAllListeners();
      }
      close() {
        if (this.socket) {
          this.socket.close();
        } else {
          this.onClose();
        }
      }
      error(payload, message, code = -1) {
        this.emit("payload", { id: payload.id, jsonrpc: payload.jsonrpc, error: { message, code } });
      }
      send(payload) {
        if (this.socket && this.socket.readyState === this.socket.CONNECTING) {
          setTimeout((_) => this.send(payload), 10);
        } else if (!this.socket || this.socket.readyState > 1) {
          this.connected = false;
          this.error(payload, "Not connected");
        } else {
          this.socket.send(JSON.stringify(payload));
        }
      }
    };
    module.exports = (WebSocket2) => (url, cb) => new WebSocketConnection(WebSocket2, url, cb);
  }
});

// node_modules/eth-provider/node_modules/uuid/lib/rng-browser.js
var require_rng_browser = __commonJS({
  "node_modules/eth-provider/node_modules/uuid/lib/rng-browser.js"(exports, module) {
    var getRandomValues = typeof crypto != "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto != "undefined" && typeof window.msCrypto.getRandomValues == "function" && msCrypto.getRandomValues.bind(msCrypto);
    if (getRandomValues) {
      rnds8 = new Uint8Array(16);
      module.exports = function whatwgRNG() {
        getRandomValues(rnds8);
        return rnds8;
      };
    } else {
      rnds = new Array(16);
      module.exports = function mathRNG() {
        for (var i = 0, r; i < 16; i++) {
          if ((i & 3) === 0)
            r = Math.random() * 4294967296;
          rnds[i] = r >>> ((i & 3) << 3) & 255;
        }
        return rnds;
      };
    }
    var rnds8;
    var rnds;
  }
});

// node_modules/eth-provider/node_modules/uuid/lib/bytesToUuid.js
var require_bytesToUuid = __commonJS({
  "node_modules/eth-provider/node_modules/uuid/lib/bytesToUuid.js"(exports, module) {
    var byteToHex = [];
    for (i = 0; i < 256; ++i) {
      byteToHex[i] = (i + 256).toString(16).substr(1);
    }
    var i;
    function bytesToUuid(buf, offset) {
      var i2 = offset || 0;
      var bth = byteToHex;
      return [
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        "-",
        bth[buf[i2++]],
        bth[buf[i2++]],
        "-",
        bth[buf[i2++]],
        bth[buf[i2++]],
        "-",
        bth[buf[i2++]],
        bth[buf[i2++]],
        "-",
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]]
      ].join("");
    }
    module.exports = bytesToUuid;
  }
});

// node_modules/eth-provider/node_modules/uuid/v4.js
var require_v4 = __commonJS({
  "node_modules/eth-provider/node_modules/uuid/v4.js"(exports, module) {
    var rng = require_rng_browser();
    var bytesToUuid = require_bytesToUuid();
    function v4(options, buf, offset) {
      var i = buf && offset || 0;
      if (typeof options == "string") {
        buf = options === "binary" ? new Array(16) : null;
        options = null;
      }
      options = options || {};
      var rnds = options.random || (options.rng || rng)();
      rnds[6] = rnds[6] & 15 | 64;
      rnds[8] = rnds[8] & 63 | 128;
      if (buf) {
        for (var ii = 0; ii < 16; ++ii) {
          buf[i + ii] = rnds[ii];
        }
      }
      return buf || bytesToUuid(rnds);
    }
    module.exports = v4;
  }
});

// node_modules/eth-provider/connections/http.js
var require_http = __commonJS({
  "node_modules/eth-provider/connections/http.js"(exports, module) {
    var EventEmitter = require_events();
    var uuid = require_v4();
    var dev = true;
    var XHR;
    var HTTPConnection = class extends EventEmitter {
      constructor(_XHR, url, options) {
        super();
        XHR = _XHR;
        this.connected = false;
        this.subscriptions = false;
        this.status = "loading";
        this.url = url;
        this.pollId = uuid();
        setTimeout(() => this.create(), 0);
      }
      create() {
        if (!XHR)
          return this.emit("error", new Error("No HTTP transport available"));
        this.on("error", () => {
          if (this.connected)
            this.close();
        });
        this.init();
      }
      init() {
        this.send({ jsonrpc: "2.0", method: "eth_syncing", params: [], id: 1 }, (err, response) => {
          if (err)
            return this.emit("error", err);
          this.send({ jsonrpc: "2.0", id: 1, method: "eth_pollSubscriptions", params: [this.pollId, "immediate"] }, (err2, response2) => {
            if (!err2) {
              this.subscriptions = true;
              this.pollSubscriptions();
            }
            this.connected = true;
            this.emit("connect");
          });
        });
      }
      pollSubscriptions() {
        this.send({ jsonrpc: "2.0", id: 1, method: "eth_pollSubscriptions", params: [this.pollId] }, (err, result) => {
          if (err) {
            this.subscriptionTimeout = setTimeout(() => this.pollSubscriptions(), 1e4);
            return this.emit("error", err);
          } else {
            if (!this.closed)
              this.subscriptionTimeout = this.pollSubscriptions();
            if (result) {
              result.map((p) => {
                let parse;
                try {
                  parse = JSON.parse(p);
                } catch (e) {
                  parse = false;
                }
                return parse;
              }).filter((n) => n).forEach((p) => this.emit("payload", p));
            }
          }
        });
      }
      close() {
        if (dev)
          console.log("Closing HTTP connection");
        this.closed = true;
        this.emit("close");
        clearTimeout(this.subscriptionTimeout);
        this.removeAllListeners();
      }
      filterStatus(res) {
        if (res.status >= 200 && res.status < 300)
          return res;
        const error = new Error(res.statusText);
        error.res = res;
        throw error.message;
      }
      error(payload, message, code = -1) {
        this.emit("payload", { id: payload.id, jsonrpc: payload.jsonrpc, error: { message, code } });
      }
      send(payload, internal) {
        if (this.closed)
          return this.error(payload, "Not connected");
        if (payload.method === "eth_subscribe") {
          if (this.subscriptions) {
            payload.pollId = this.pollId;
          } else {
            return this.error(payload, "Subscriptions are not supported by this HTTP endpoint");
          }
        }
        const xhr = new XHR();
        let responded = false;
        const res = (err, result) => {
          if (!responded) {
            xhr.abort();
            responded = true;
            if (internal) {
              internal(err, result);
            } else {
              const { id, jsonrpc } = payload;
              const load = err ? { id, jsonrpc, error: { message: err.message, code: err.code } } : { id, jsonrpc, result };
              this.emit("payload", load);
            }
          }
        };
        xhr.open("POST", this.url, true);
        xhr.setRequestHeader("Content-Type", "application/json");
        xhr.timeout = 60 * 1e3;
        xhr.onerror = res;
        xhr.ontimeout = res;
        xhr.onreadystatechange = () => {
          if (xhr.readyState === 4) {
            try {
              const response = JSON.parse(xhr.responseText);
              res(response.error, response.result);
            } catch (e) {
              res(e);
            }
          }
        };
        xhr.send(JSON.stringify(payload));
      }
    };
    module.exports = (XHR2) => (url, options) => new HTTPConnection(XHR2, url, options);
  }
});

// node_modules/eth-provider/browser.js
var require_browser = __commonJS({
  "node_modules/eth-provider/browser.js"(exports, module) {
    var resolve = require_resolve();
    var provider = require_provider();
    var presets = require_presets();
    var injected = {
      ethereum: typeof window !== "undefined" && typeof window.ethereum !== "undefined" ? window.ethereum : null,
      web3: typeof window !== "undefined" && typeof window.web3 !== "undefined" ? window.web3.currentProvider : null
    };
    var ws = typeof window !== "undefined" && typeof window.WebSocket !== "undefined" ? window.WebSocket : null;
    var XHR = typeof window !== "undefined" && typeof window.XMLHttpRequest !== "undefined" ? window.XMLHttpRequest : null;
    if (injected.ethereum)
      injected.ethereum.__isProvider = true;
    var connections = {
      injected: injected.ethereum || require_injected()(injected.web3),
      ipc: require_unavailable()("IPC connections are unavliable in the browser"),
      ws: require_ws()(ws),
      http: require_http()(XHR)
    };
    module.exports = (targets = ["injected", "frame"], options = {}) => provider(connections, resolve(targets, presets), options);
  }
});

// node_modules/@web3-react/frame-connector/dist/frame-connector.esm.js
var import_eth_provider = __toESM(require_browser());
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf(o);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct2(Parent2, args2, Class2) {
      var a = [null];
      a.push.apply(a, args2);
      var Constructor = Function.bind.apply(Parent2, a);
      var instance = new Constructor();
      if (Class2)
        _setPrototypeOf(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
  _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
    if (Class2 === null || !_isNativeFunction(Class2))
      return Class2;
    if (typeof Class2 !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class2))
        return _cache.get(Class2);
      _cache.set(Class2, Wrapper);
    }
    function Wrapper() {
      return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
    }
    Wrapper.prototype = Object.create(Class2.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class2);
  };
  return _wrapNativeSuper(Class);
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
var UserRejectedRequestError = function(_Error) {
  _inheritsLoose(UserRejectedRequestError2, _Error);
  function UserRejectedRequestError2() {
    var _this;
    _this = _Error.call(this) || this;
    _this.name = _this.constructor.name;
    _this.message = "The user rejected the request.";
    return _this;
  }
  return UserRejectedRequestError2;
}(_wrapNativeSuper(Error));
var FrameConnector = function(_AbstractConnector) {
  _inheritsLoose(FrameConnector2, _AbstractConnector);
  function FrameConnector2(kwargs) {
    var _this2;
    !(kwargs.supportedChainIds.length === 1) ? true ? invariant(false, "This connector only supports 1 chainId at the moment.") : invariant(false) : void 0;
    _this2 = _AbstractConnector.call(this, kwargs) || this;
    _this2.handleNetworkChanged = _this2.handleNetworkChanged.bind(_assertThisInitialized(_this2));
    _this2.handleChainChanged = _this2.handleChainChanged.bind(_assertThisInitialized(_this2));
    _this2.handleAccountsChanged = _this2.handleAccountsChanged.bind(_assertThisInitialized(_this2));
    _this2.handleClose = _this2.handleClose.bind(_assertThisInitialized(_this2));
    return _this2;
  }
  var _proto = FrameConnector2.prototype;
  _proto.handleNetworkChanged = function handleNetworkChanged(networkId) {
    if (true) {
      console.log("Handling 'networkChanged' event with payload", networkId);
    }
    this.emitUpdate({
      provider: this.provider,
      chainId: networkId
    });
  };
  _proto.handleChainChanged = function handleChainChanged(chainId) {
    if (true) {
      console.log("Handling 'chainChanged' event with payload", chainId);
    }
    this.emitUpdate({
      chainId
    });
  };
  _proto.handleAccountsChanged = function handleAccountsChanged(accounts) {
    if (true) {
      console.log("Handling 'accountsChanged' event with payload", accounts);
    }
    this.emitUpdate({
      account: accounts.length === 0 ? null : accounts[0]
    });
  };
  _proto.handleClose = function handleClose(code, reason) {
    if (true) {
      console.log("Handling 'close' event with payload", code, reason);
    }
    this.emitDeactivate();
  };
  _proto.activate = function activate() {
    try {
      var _this4 = this;
      if (!_this4.provider) {
        _this4.provider = (0, import_eth_provider.default)("frame");
      }
      _this4.provider.on("networkChanged", _this4.handleNetworkChanged).on("chainChanged", _this4.handleChainChanged).on("accountsChanged", _this4.handleAccountsChanged).on("close", _this4.handleClose);
      return Promise.resolve(_this4.provider.enable().then(function(accounts) {
        return accounts[0];
      })["catch"](function(error) {
        if (error && error.code === 4001) {
          throw new UserRejectedRequestError();
        } else {
          throw error;
        }
      })).then(function(account) {
        return {
          provider: _this4.provider,
          account
        };
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };
  _proto.getProvider = function getProvider() {
    try {
      var _this6 = this;
      return Promise.resolve(_this6.provider);
    } catch (e) {
      return Promise.reject(e);
    }
  };
  _proto.getChainId = function getChainId() {
    try {
      var _this8 = this;
      return Promise.resolve(_this8.provider.send("eth_chainId"));
    } catch (e) {
      return Promise.reject(e);
    }
  };
  _proto.getAccount = function getAccount() {
    try {
      var _this10 = this;
      return Promise.resolve(_this10.provider.send("eth_accounts").then(function(accounts) {
        return accounts[0];
      }));
    } catch (e) {
      return Promise.reject(e);
    }
  };
  _proto.deactivate = function deactivate() {
    this.provider.removeListener("networkChanged", this.handleNetworkChanged).removeListener("chainChanged", this.handleChainChanged).removeListener("accountsChanged", this.handleAccountsChanged).removeListener("close", this.handleClose);
  };
  return FrameConnector2;
}(AbstractConnector);
export {
  FrameConnector,
  UserRejectedRequestError
};
//# sourceMappingURL=frame-connector.esm-DXZ73KFB.js.map
