import {
  require_sha3
} from "./chunk-NF36MAEQ.js";
import {
  invariant
} from "./chunk-XUSVWCLU.js";
import {
  tiny_warning_esm_default
} from "./chunk-OWMJGVW2.js";
import {
  ConnectorEvent
} from "./chunk-LPPLLAJT.js";
import {
  require_prop_types
} from "./chunk-5YRTH3KM.js";
import {
  require_react
} from "./chunk-YVDZNGKE.js";
import {
  __toESM
} from "./chunk-IKJM6GHQ.js";

// node_modules/use-wallet/dist/esm/index.js
var import_prop_types = __toESM(require_prop_types());
var import_react2 = __toESM(require_react());

// node_modules/@web3-react/core/dist/core.esm.js
var import_react = __toESM(require_react());

// node_modules/@ethersproject/logger/lib.esm/_version.js
var version = "logger/5.7.0";

// node_modules/@ethersproject/logger/lib.esm/index.js
var _permanentCensorErrors = false;
var _censorErrors = false;
var LogLevels = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
var _logLevel = LogLevels["default"];
var _globalLogger = null;
function _checkNormalize() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
var _normalizeError = _checkNormalize();
var LogLevel;
(function(LogLevel2) {
  LogLevel2["DEBUG"] = "DEBUG";
  LogLevel2["INFO"] = "INFO";
  LogLevel2["WARNING"] = "WARNING";
  LogLevel2["ERROR"] = "ERROR";
  LogLevel2["OFF"] = "OFF";
})(LogLevel || (LogLevel = {}));
var ErrorCode;
(function(ErrorCode2) {
  ErrorCode2["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
  ErrorCode2["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
  ErrorCode2["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
  ErrorCode2["NETWORK_ERROR"] = "NETWORK_ERROR";
  ErrorCode2["SERVER_ERROR"] = "SERVER_ERROR";
  ErrorCode2["TIMEOUT"] = "TIMEOUT";
  ErrorCode2["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
  ErrorCode2["NUMERIC_FAULT"] = "NUMERIC_FAULT";
  ErrorCode2["MISSING_NEW"] = "MISSING_NEW";
  ErrorCode2["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
  ErrorCode2["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
  ErrorCode2["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
  ErrorCode2["CALL_EXCEPTION"] = "CALL_EXCEPTION";
  ErrorCode2["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
  ErrorCode2["NONCE_EXPIRED"] = "NONCE_EXPIRED";
  ErrorCode2["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
  ErrorCode2["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
  ErrorCode2["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
  ErrorCode2["ACTION_REJECTED"] = "ACTION_REJECTED";
})(ErrorCode || (ErrorCode = {}));
var HEX = "0123456789abcdef";
var Logger = class {
  constructor(version3) {
    Object.defineProperty(this, "version", {
      enumerable: true,
      value: version3,
      writable: false
    });
  }
  _log(logLevel, args) {
    const level = logLevel.toLowerCase();
    if (LogLevels[level] == null) {
      this.throwArgumentError("invalid log level name", "logLevel", logLevel);
    }
    if (_logLevel > LogLevels[level]) {
      return;
    }
    console.log.apply(console, args);
  }
  debug(...args) {
    this._log(Logger.levels.DEBUG, args);
  }
  info(...args) {
    this._log(Logger.levels.INFO, args);
  }
  warn(...args) {
    this._log(Logger.levels.WARNING, args);
  }
  makeError(message, code, params) {
    if (_censorErrors) {
      return this.makeError("censored error", code, {});
    }
    if (!code) {
      code = Logger.errors.UNKNOWN_ERROR;
    }
    if (!params) {
      params = {};
    }
    const messageDetails = [];
    Object.keys(params).forEach((key) => {
      const value = params[key];
      try {
        if (value instanceof Uint8Array) {
          let hex = "";
          for (let i = 0; i < value.length; i++) {
            hex += HEX[value[i] >> 4];
            hex += HEX[value[i] & 15];
          }
          messageDetails.push(key + "=Uint8Array(0x" + hex + ")");
        } else {
          messageDetails.push(key + "=" + JSON.stringify(value));
        }
      } catch (error2) {
        messageDetails.push(key + "=" + JSON.stringify(params[key].toString()));
      }
    });
    messageDetails.push(`code=${code}`);
    messageDetails.push(`version=${this.version}`);
    const reason = message;
    let url = "";
    switch (code) {
      case ErrorCode.NUMERIC_FAULT: {
        url = "NUMERIC_FAULT";
        const fault = message;
        switch (fault) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            url += "-" + fault;
            break;
          case "negative-power":
          case "negative-width":
            url += "-unsupported";
            break;
          case "unbound-bitwise-result":
            url += "-unbound-result";
            break;
        }
        break;
      }
      case ErrorCode.CALL_EXCEPTION:
      case ErrorCode.INSUFFICIENT_FUNDS:
      case ErrorCode.MISSING_NEW:
      case ErrorCode.NONCE_EXPIRED:
      case ErrorCode.REPLACEMENT_UNDERPRICED:
      case ErrorCode.TRANSACTION_REPLACED:
      case ErrorCode.UNPREDICTABLE_GAS_LIMIT:
        url = code;
        break;
    }
    if (url) {
      message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
    }
    if (messageDetails.length) {
      message += " (" + messageDetails.join(", ") + ")";
    }
    const error = new Error(message);
    error.reason = reason;
    error.code = code;
    Object.keys(params).forEach(function(key) {
      error[key] = params[key];
    });
    return error;
  }
  throwError(message, code, params) {
    throw this.makeError(message, code, params);
  }
  throwArgumentError(message, name, value) {
    return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {
      argument: name,
      value
    });
  }
  assert(condition, message, code, params) {
    if (!!condition) {
      return;
    }
    this.throwError(message, code, params);
  }
  assertArgument(condition, message, name, value) {
    if (!!condition) {
      return;
    }
    this.throwArgumentError(message, name, value);
  }
  checkNormalize(message) {
    if (message == null) {
      message = "platform missing String.prototype.normalize";
    }
    if (_normalizeError) {
      this.throwError("platform missing String.prototype.normalize", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "String.prototype.normalize",
        form: _normalizeError
      });
    }
  }
  checkSafeUint53(value, message) {
    if (typeof value !== "number") {
      return;
    }
    if (message == null) {
      message = "value not safe";
    }
    if (value < 0 || value >= 9007199254740991) {
      this.throwError(message, Logger.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "out-of-safe-range",
        value
      });
    }
    if (value % 1) {
      this.throwError(message, Logger.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "non-integer",
        value
      });
    }
  }
  checkArgumentCount(count, expectedCount, message) {
    if (message) {
      message = ": " + message;
    } else {
      message = "";
    }
    if (count < expectedCount) {
      this.throwError("missing argument" + message, Logger.errors.MISSING_ARGUMENT, {
        count,
        expectedCount
      });
    }
    if (count > expectedCount) {
      this.throwError("too many arguments" + message, Logger.errors.UNEXPECTED_ARGUMENT, {
        count,
        expectedCount
      });
    }
  }
  checkNew(target, kind) {
    if (target === Object || target == null) {
      this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });
    }
  }
  checkAbstract(target, kind) {
    if (target === kind) {
      this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
    } else if (target === Object || target == null) {
      this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });
    }
  }
  static globalLogger() {
    if (!_globalLogger) {
      _globalLogger = new Logger(version);
    }
    return _globalLogger;
  }
  static setCensorship(censorship, permanent) {
    if (!censorship && permanent) {
      this.globalLogger().throwError("cannot permanently disable censorship", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    if (_permanentCensorErrors) {
      if (!censorship) {
        return;
      }
      this.globalLogger().throwError("error censorship permanent", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors = !!censorship;
    _permanentCensorErrors = !!permanent;
  }
  static setLogLevel(logLevel) {
    const level = LogLevels[logLevel.toLowerCase()];
    if (level == null) {
      Logger.globalLogger().warn("invalid log level - " + logLevel);
      return;
    }
    _logLevel = level;
  }
  static from(version3) {
    return new Logger(version3);
  }
};
Logger.errors = ErrorCode;
Logger.levels = LogLevel;

// node_modules/@ethersproject/bytes/lib.esm/_version.js
var version2 = "bytes/5.7.0";

// node_modules/@ethersproject/bytes/lib.esm/index.js
var logger = new Logger(version2);
function isHexable(value) {
  return !!value.toHexString;
}
function addSlice(array) {
  if (array.slice) {
    return array;
  }
  array.slice = function() {
    const args = Array.prototype.slice.call(arguments);
    return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));
  };
  return array;
}
function isInteger(value) {
  return typeof value === "number" && value == value && value % 1 === 0;
}
function isBytes(value) {
  if (value == null) {
    return false;
  }
  if (value.constructor === Uint8Array) {
    return true;
  }
  if (typeof value === "string") {
    return false;
  }
  if (!isInteger(value.length) || value.length < 0) {
    return false;
  }
  for (let i = 0; i < value.length; i++) {
    const v = value[i];
    if (!isInteger(v) || v < 0 || v >= 256) {
      return false;
    }
  }
  return true;
}
function arrayify(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger.checkSafeUint53(value, "invalid arrayify value");
    const result = [];
    while (value) {
      result.unshift(value & 255);
      value = parseInt(String(value / 256));
    }
    if (result.length === 0) {
      result.push(0);
    }
    return addSlice(new Uint8Array(result));
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable(value)) {
    value = value.toHexString();
  }
  if (isHexString(value)) {
    let hex = value.substring(2);
    if (hex.length % 2) {
      if (options.hexPad === "left") {
        hex = "0" + hex;
      } else if (options.hexPad === "right") {
        hex += "0";
      } else {
        logger.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    const result = [];
    for (let i = 0; i < hex.length; i += 2) {
      result.push(parseInt(hex.substring(i, i + 2), 16));
    }
    return addSlice(new Uint8Array(result));
  }
  if (isBytes(value)) {
    return addSlice(new Uint8Array(value));
  }
  return logger.throwArgumentError("invalid arrayify value", "value", value);
}
function isHexString(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length && value.length !== 2 + 2 * length) {
    return false;
  }
  return true;
}

// node_modules/@ethersproject/keccak256/lib.esm/index.js
var import_js_sha3 = __toESM(require_sha3());
function keccak256(data) {
  return "0x" + import_js_sha3.default.keccak_256(arrayify(data));
}

// node_modules/@web3-react/core/dist/core.esm.js
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf(o);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct3(Parent2, args2, Class2) {
      var a = [null];
      a.push.apply(a, args2);
      var Constructor = Function.bind.apply(Parent2, a);
      var instance = new Constructor();
      if (Class2)
        _setPrototypeOf(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
  _wrapNativeSuper = function _wrapNativeSuper3(Class2) {
    if (Class2 === null || !_isNativeFunction(Class2))
      return Class2;
    if (typeof Class2 !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class2))
        return _cache.get(Class2);
      _cache.set(Class2, Wrapper);
    }
    function Wrapper() {
      return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
    }
    Wrapper.prototype = Object.create(Class2.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class2);
  };
  return _wrapNativeSuper(Class);
}
var _iteratorSymbol = typeof Symbol !== "undefined" ? Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator")) : "@@iterator";
var _asyncIteratorSymbol = typeof Symbol !== "undefined" ? Symbol.asyncIterator || (Symbol.asyncIterator = Symbol("Symbol.asyncIterator")) : "@@asyncIterator";
function _catch(body, recover) {
  try {
    var result = body();
  } catch (e) {
    return recover(e);
  }
  if (result && result.then) {
    return result.then(void 0, recover);
  }
  return result;
}
function normalizeChainId(chainId) {
  if (typeof chainId === "string") {
    chainId = chainId.replace(/^Ox/, "0x");
    var parsedChainId = Number.parseInt(chainId, chainId.trim().substring(0, 2) === "0x" ? 16 : 10);
    !!Number.isNaN(parsedChainId) ? true ? invariant(false, "chainId " + chainId + " is not an integer") : invariant(false) : void 0;
    return parsedChainId;
  } else {
    !Number.isInteger(chainId) ? true ? invariant(false, "chainId " + chainId + " is not an integer") : invariant(false) : void 0;
    return chainId;
  }
}
function normalizeAccount(_address) {
  !(typeof _address === "string" && _address.match(/^(0x)?[0-9a-fA-F]{40}$/)) ? true ? invariant(false, "Invalid address " + _address) : invariant(false) : void 0;
  var address = _address.substring(0, 2) === "0x" ? _address : "0x" + _address;
  var chars = address.toLowerCase().substring(2).split("");
  var charsArray = new Uint8Array(40);
  for (var i = 0; i < 40; i++) {
    charsArray[i] = chars[i].charCodeAt(0);
  }
  var hashed = arrayify(keccak256(charsArray));
  for (var _i = 0; _i < 40; _i += 2) {
    if (hashed[_i >> 1] >> 4 >= 8) {
      chars[_i] = chars[_i].toUpperCase();
    }
    if ((hashed[_i >> 1] & 15) >= 8) {
      chars[_i + 1] = chars[_i + 1].toUpperCase();
    }
  }
  var addressChecksum = "0x" + chars.join("");
  !!(address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && address !== addressChecksum) ? true ? invariant(false, "Bad address checksum " + address + " " + addressChecksum) : invariant(false) : void 0;
  return addressChecksum;
}
var augmentConnectorUpdate = function augmentConnectorUpdate2(connector, update) {
  try {
    var _temp3 = function _temp32(provider) {
      return Promise.resolve(Promise.all([update.chainId === void 0 ? connector.getChainId() : update.chainId, update.account === void 0 ? connector.getAccount() : update.account])).then(function(_ref2) {
        var _chainId = _ref2[0], _account = _ref2[1];
        var chainId = normalizeChainId(_chainId);
        if (!!connector.supportedChainIds && !connector.supportedChainIds.includes(chainId)) {
          throw new UnsupportedChainIdError(chainId, connector.supportedChainIds);
        }
        var account = _account === null ? _account : normalizeAccount(_account);
        return {
          provider,
          chainId,
          account
        };
      });
    };
    var _temp4 = update.provider === void 0;
    return Promise.resolve(_temp4 ? Promise.resolve(connector.getProvider()).then(_temp3) : _temp3(update.provider));
  } catch (e) {
    return Promise.reject(e);
  }
};
var StaleConnectorError = function(_Error) {
  _inheritsLoose(StaleConnectorError2, _Error);
  function StaleConnectorError2() {
    var _this;
    _this = _Error.call(this) || this;
    _this.name = _this.constructor.name;
    return _this;
  }
  return StaleConnectorError2;
}(_wrapNativeSuper(Error));
var UnsupportedChainIdError = function(_Error2) {
  _inheritsLoose(UnsupportedChainIdError2, _Error2);
  function UnsupportedChainIdError2(unsupportedChainId, supportedChainIds) {
    var _this2;
    _this2 = _Error2.call(this) || this;
    _this2.name = _this2.constructor.name;
    _this2.message = "Unsupported chain id: " + unsupportedChainId + ". Supported chain ids are: " + supportedChainIds + ".";
    return _this2;
  }
  return UnsupportedChainIdError2;
}(_wrapNativeSuper(Error));
var ActionType;
(function(ActionType2) {
  ActionType2[ActionType2["ACTIVATE_CONNECTOR"] = 0] = "ACTIVATE_CONNECTOR";
  ActionType2[ActionType2["UPDATE"] = 1] = "UPDATE";
  ActionType2[ActionType2["UPDATE_FROM_ERROR"] = 2] = "UPDATE_FROM_ERROR";
  ActionType2[ActionType2["ERROR"] = 3] = "ERROR";
  ActionType2[ActionType2["ERROR_FROM_ACTIVATION"] = 4] = "ERROR_FROM_ACTIVATION";
  ActionType2[ActionType2["DEACTIVATE_CONNECTOR"] = 5] = "DEACTIVATE_CONNECTOR";
})(ActionType || (ActionType = {}));
function reducer(state, _ref) {
  var type = _ref.type, payload = _ref.payload;
  switch (type) {
    case ActionType.ACTIVATE_CONNECTOR: {
      var connector = payload.connector, provider = payload.provider, chainId = payload.chainId, account = payload.account, onError = payload.onError;
      return {
        connector,
        provider,
        chainId,
        account,
        onError
      };
    }
    case ActionType.UPDATE: {
      var _provider = payload.provider, _chainId2 = payload.chainId, _account2 = payload.account;
      return _extends({}, state, _provider === void 0 ? {} : {
        provider: _provider
      }, _chainId2 === void 0 ? {} : {
        chainId: _chainId2
      }, _account2 === void 0 ? {} : {
        account: _account2
      });
    }
    case ActionType.UPDATE_FROM_ERROR: {
      var _provider2 = payload.provider, _chainId3 = payload.chainId, _account3 = payload.account;
      return _extends({}, state, _provider2 === void 0 ? {} : {
        provider: _provider2
      }, _chainId3 === void 0 ? {} : {
        chainId: _chainId3
      }, _account3 === void 0 ? {} : {
        account: _account3
      }, {
        error: void 0
      });
    }
    case ActionType.ERROR: {
      var error = payload.error;
      var _connector = state.connector, _onError = state.onError;
      return {
        connector: _connector,
        error,
        onError: _onError
      };
    }
    case ActionType.ERROR_FROM_ACTIVATION: {
      var _connector2 = payload.connector, _error = payload.error;
      return {
        connector: _connector2,
        error: _error
      };
    }
    case ActionType.DEACTIVATE_CONNECTOR: {
      return {};
    }
  }
}
function useWeb3ReactManager() {
  var _useReducer = (0, import_react.useReducer)(reducer, {}), state = _useReducer[0], dispatch = _useReducer[1];
  var connector = state.connector, provider = state.provider, chainId = state.chainId, account = state.account, onError = state.onError, error = state.error;
  var updateBusterRef = (0, import_react.useRef)(-1);
  updateBusterRef.current += 1;
  var activate = (0, import_react.useCallback)(function(connector2, onError2, throwErrors) {
    if (throwErrors === void 0) {
      throwErrors = false;
    }
    try {
      var updateBusterInitial = updateBusterRef.current;
      var activated = false;
      return Promise.resolve(_catch(function() {
        return Promise.resolve(connector2.activate().then(function(update) {
          activated = true;
          return update;
        })).then(function(update) {
          return Promise.resolve(augmentConnectorUpdate(connector2, update)).then(function(augmentedUpdate) {
            if (updateBusterRef.current > updateBusterInitial) {
              throw new StaleConnectorError();
            }
            dispatch({
              type: ActionType.ACTIVATE_CONNECTOR,
              payload: _extends({
                connector: connector2
              }, augmentedUpdate, {
                onError: onError2
              })
            });
          });
        });
      }, function(error2) {
        if (error2 instanceof StaleConnectorError) {
          activated && connector2.deactivate();
          true ? tiny_warning_esm_default(false, "Suppressed stale connector activation " + connector2) : void 0;
        } else if (throwErrors) {
          activated && connector2.deactivate();
          throw error2;
        } else if (onError2) {
          activated && connector2.deactivate();
          onError2(error2);
        } else {
          dispatch({
            type: ActionType.ERROR_FROM_ACTIVATION,
            payload: {
              connector: connector2,
              error: error2
            }
          });
        }
      }));
    } catch (e) {
      return Promise.reject(e);
    }
  }, []);
  var setError = (0, import_react.useCallback)(function(error2) {
    dispatch({
      type: ActionType.ERROR,
      payload: {
        error: error2
      }
    });
  }, []);
  var deactivate = (0, import_react.useCallback)(function() {
    dispatch({
      type: ActionType.DEACTIVATE_CONNECTOR
    });
  }, []);
  var handleUpdate = (0, import_react.useCallback)(function(update) {
    try {
      if (!connector) {
        throw Error("This should never happen, it's just so Typescript stops complaining");
      }
      var updateBusterInitial = updateBusterRef.current;
      return Promise.resolve(function() {
        if (!error) {
          var _chainId4 = update.chainId === void 0 ? void 0 : normalizeChainId(update.chainId);
          if (_chainId4 !== void 0 && !!connector.supportedChainIds && !connector.supportedChainIds.includes(_chainId4)) {
            var _error2 = new UnsupportedChainIdError(_chainId4, connector.supportedChainIds);
            onError ? onError(_error2) : dispatch({
              type: ActionType.ERROR,
              payload: {
                error: _error2
              }
            });
          } else {
            var _account4 = typeof update.account === "string" ? normalizeAccount(update.account) : update.account;
            dispatch({
              type: ActionType.UPDATE,
              payload: {
                provider: update.provider,
                chainId: _chainId4,
                account: _account4
              }
            });
          }
        } else {
          return _catch(function() {
            return Promise.resolve(augmentConnectorUpdate(connector, update)).then(function(augmentedUpdate) {
              if (updateBusterRef.current > updateBusterInitial) {
                throw new StaleConnectorError();
              }
              dispatch({
                type: ActionType.UPDATE_FROM_ERROR,
                payload: augmentedUpdate
              });
            });
          }, function(error2) {
            if (error2 instanceof StaleConnectorError) {
              true ? tiny_warning_esm_default(false, "Suppressed stale connector update from error state " + connector + " " + update) : void 0;
            } else {
              onError ? onError(error2) : dispatch({
                type: ActionType.ERROR,
                payload: {
                  error: error2
                }
              });
            }
          });
        }
      }());
    } catch (e) {
      return Promise.reject(e);
    }
  }, [connector, error, onError]);
  var handleError = (0, import_react.useCallback)(function(error2) {
    onError ? onError(error2) : dispatch({
      type: ActionType.ERROR,
      payload: {
        error: error2
      }
    });
  }, [onError]);
  var handleDeactivate = (0, import_react.useCallback)(function() {
    dispatch({
      type: ActionType.DEACTIVATE_CONNECTOR
    });
  }, []);
  (0, import_react.useEffect)(function() {
    return function() {
      if (connector) {
        connector.deactivate();
      }
    };
  }, [connector]);
  (0, import_react.useEffect)(function() {
    if (connector) {
      connector.on(ConnectorEvent.Update, handleUpdate).on(ConnectorEvent.Error, handleError).on(ConnectorEvent.Deactivate, handleDeactivate);
    }
    return function() {
      if (connector) {
        connector.off(ConnectorEvent.Update, handleUpdate).off(ConnectorEvent.Error, handleError).off(ConnectorEvent.Deactivate, handleDeactivate);
      }
    };
  }, [connector, handleUpdate, handleError, handleDeactivate]);
  return {
    connector,
    provider,
    chainId,
    account,
    activate,
    setError,
    deactivate,
    error
  };
}
var PRIMARY_KEY = "primary";
var CONTEXTS = {};
function createWeb3ReactRoot(key) {
  !!CONTEXTS[key] ? true ? invariant(false, "A root already exists for provided key " + key) : invariant(false) : void 0;
  CONTEXTS[key] = (0, import_react.createContext)({
    activate: function() {
      try {
        true ? true ? invariant(false, "No <Web3ReactProvider ... /> found.") : invariant(false) : void 0;
        return Promise.resolve();
      } catch (e) {
        return Promise.reject(e);
      }
    },
    setError: function setError() {
      true ? invariant(false, "No <Web3ReactProvider ... /> found.") : invariant(false);
    },
    deactivate: function deactivate() {
      true ? invariant(false, "No <Web3ReactProvider ... /> found.") : invariant(false);
    },
    active: false
  });
  CONTEXTS[key].displayName = "Web3ReactContext - " + key;
  var Provider = CONTEXTS[key].Provider;
  return function Web3ReactProvider2(_ref) {
    var getLibrary = _ref.getLibrary, children = _ref.children;
    var _useWeb3ReactManager = useWeb3ReactManager(), connector = _useWeb3ReactManager.connector, provider = _useWeb3ReactManager.provider, chainId = _useWeb3ReactManager.chainId, account = _useWeb3ReactManager.account, activate = _useWeb3ReactManager.activate, setError = _useWeb3ReactManager.setError, deactivate = _useWeb3ReactManager.deactivate, error = _useWeb3ReactManager.error;
    var active = connector !== void 0 && chainId !== void 0 && account !== void 0 && !!!error;
    var library = (0, import_react.useMemo)(function() {
      return active && chainId !== void 0 && Number.isInteger(chainId) && !!connector ? getLibrary(provider, connector) : void 0;
    }, [active, getLibrary, provider, connector, chainId]);
    var web3ReactContext = {
      connector,
      library,
      chainId,
      account,
      activate,
      setError,
      deactivate,
      active,
      error
    };
    return import_react.default.createElement(Provider, {
      value: web3ReactContext
    }, children);
  };
}
var Web3ReactProvider = createWeb3ReactRoot(PRIMARY_KEY);
function getWeb3ReactContext(key) {
  if (key === void 0) {
    key = PRIMARY_KEY;
  }
  !Object.keys(CONTEXTS).includes(key) ? true ? invariant(false, "Invalid key " + key) : invariant(false) : void 0;
  return CONTEXTS[key];
}
function useWeb3React(key) {
  return (0, import_react.useContext)(getWeb3ReactContext(key));
}

// node_modules/jsbi/dist/jsbi.mjs
var JSBI = class extends Array {
  constructor(i, _) {
    if (super(i), this.sign = _, i > JSBI.__kMaxLength)
      throw new RangeError("Maximum BigInt size exceeded");
  }
  static BigInt(i) {
    var _ = Math.floor, t = Number.isFinite;
    if ("number" == typeof i) {
      if (0 === i)
        return JSBI.__zero();
      if (JSBI.__isOneDigitInt(i))
        return 0 > i ? JSBI.__oneDigit(-i, true) : JSBI.__oneDigit(i, false);
      if (!t(i) || _(i) !== i)
        throw new RangeError("The number " + i + " cannot be converted to BigInt because it is not an integer");
      return JSBI.__fromDouble(i);
    }
    if ("string" == typeof i) {
      const _2 = JSBI.__fromString(i);
      if (null === _2)
        throw new SyntaxError("Cannot convert " + i + " to a BigInt");
      return _2;
    }
    if ("boolean" == typeof i)
      return true === i ? JSBI.__oneDigit(1, false) : JSBI.__zero();
    if ("object" == typeof i) {
      if (i.constructor === JSBI)
        return i;
      const _2 = JSBI.__toPrimitive(i);
      return JSBI.BigInt(_2);
    }
    throw new TypeError("Cannot convert " + i + " to a BigInt");
  }
  toDebugString() {
    const i = ["BigInt["];
    for (const _ of this)
      i.push((_ ? (_ >>> 0).toString(16) : _) + ", ");
    return i.push("]"), i.join("");
  }
  toString(i = 10) {
    if (2 > i || 36 < i)
      throw new RangeError("toString() radix argument must be between 2 and 36");
    return 0 === this.length ? "0" : 0 == (i & i - 1) ? JSBI.__toStringBasePowerOfTwo(this, i) : JSBI.__toStringGeneric(this, i, false);
  }
  static toNumber(i) {
    const _ = i.length;
    if (0 === _)
      return 0;
    if (1 === _) {
      const _2 = i.__unsignedDigit(0);
      return i.sign ? -_2 : _2;
    }
    const t = i.__digit(_ - 1), e = JSBI.__clz30(t), n = 30 * _ - e;
    if (1024 < n)
      return i.sign ? -Infinity : 1 / 0;
    let g = n - 1, o = t, s = _ - 1;
    const l = e + 3;
    let r = 32 === l ? 0 : o << l;
    r >>>= 12;
    const a = l - 12;
    let u = 12 <= l ? 0 : o << 20 + l, d = 20 + l;
    for (0 < a && 0 < s && (s--, o = i.__digit(s), r |= o >>> 30 - a, u = o << a + 2, d = a + 2); 0 < d && 0 < s; )
      s--, o = i.__digit(s), u |= 30 <= d ? o << d - 30 : o >>> 30 - d, d -= 30;
    const h = JSBI.__decideRounding(i, d, s, o);
    if ((1 === h || 0 === h && 1 == (1 & u)) && (u = u + 1 >>> 0, 0 === u && (r++, 0 != r >>> 20 && (r = 0, g++, 1023 < g))))
      return i.sign ? -Infinity : 1 / 0;
    const m = i.sign ? -2147483648 : 0;
    return g = g + 1023 << 20, JSBI.__kBitConversionInts[1] = m | g | r, JSBI.__kBitConversionInts[0] = u, JSBI.__kBitConversionDouble[0];
  }
  static unaryMinus(i) {
    if (0 === i.length)
      return i;
    const _ = i.__copy();
    return _.sign = !i.sign, _;
  }
  static bitwiseNot(i) {
    return i.sign ? JSBI.__absoluteSubOne(i).__trim() : JSBI.__absoluteAddOne(i, true);
  }
  static exponentiate(i, _) {
    if (_.sign)
      throw new RangeError("Exponent must be positive");
    if (0 === _.length)
      return JSBI.__oneDigit(1, false);
    if (0 === i.length)
      return i;
    if (1 === i.length && 1 === i.__digit(0))
      return i.sign && 0 == (1 & _.__digit(0)) ? JSBI.unaryMinus(i) : i;
    if (1 < _.length)
      throw new RangeError("BigInt too big");
    let t = _.__unsignedDigit(0);
    if (1 === t)
      return i;
    if (t >= JSBI.__kMaxLengthBits)
      throw new RangeError("BigInt too big");
    if (1 === i.length && 2 === i.__digit(0)) {
      const _2 = 1 + (0 | t / 30), e2 = i.sign && 0 != (1 & t), n2 = new JSBI(_2, e2);
      n2.__initializeDigits();
      const g = 1 << t % 30;
      return n2.__setDigit(_2 - 1, g), n2;
    }
    let e = null, n = i;
    for (0 != (1 & t) && (e = i), t >>= 1; 0 !== t; t >>= 1)
      n = JSBI.multiply(n, n), 0 != (1 & t) && (null === e ? e = n : e = JSBI.multiply(e, n));
    return e;
  }
  static multiply(_, t) {
    if (0 === _.length)
      return _;
    if (0 === t.length)
      return t;
    let i = _.length + t.length;
    30 <= _.__clzmsd() + t.__clzmsd() && i--;
    const e = new JSBI(i, _.sign !== t.sign);
    e.__initializeDigits();
    for (let n = 0; n < _.length; n++)
      JSBI.__multiplyAccumulate(t, _.__digit(n), e, n);
    return e.__trim();
  }
  static divide(i, _) {
    if (0 === _.length)
      throw new RangeError("Division by zero");
    if (0 > JSBI.__absoluteCompare(i, _))
      return JSBI.__zero();
    const t = i.sign !== _.sign, e = _.__unsignedDigit(0);
    let n;
    if (1 === _.length && 32767 >= e) {
      if (1 === e)
        return t === i.sign ? i : JSBI.unaryMinus(i);
      n = JSBI.__absoluteDivSmall(i, e, null);
    } else
      n = JSBI.__absoluteDivLarge(i, _, true, false);
    return n.sign = t, n.__trim();
  }
  static remainder(i, _) {
    if (0 === _.length)
      throw new RangeError("Division by zero");
    if (0 > JSBI.__absoluteCompare(i, _))
      return i;
    const t = _.__unsignedDigit(0);
    if (1 === _.length && 32767 >= t) {
      if (1 === t)
        return JSBI.__zero();
      const _2 = JSBI.__absoluteModSmall(i, t);
      return 0 === _2 ? JSBI.__zero() : JSBI.__oneDigit(_2, i.sign);
    }
    const e = JSBI.__absoluteDivLarge(i, _, false, true);
    return e.sign = i.sign, e.__trim();
  }
  static add(i, _) {
    const t = i.sign;
    return t === _.sign ? JSBI.__absoluteAdd(i, _, t) : 0 <= JSBI.__absoluteCompare(i, _) ? JSBI.__absoluteSub(i, _, t) : JSBI.__absoluteSub(_, i, !t);
  }
  static subtract(i, _) {
    const t = i.sign;
    return t === _.sign ? 0 <= JSBI.__absoluteCompare(i, _) ? JSBI.__absoluteSub(i, _, t) : JSBI.__absoluteSub(_, i, !t) : JSBI.__absoluteAdd(i, _, t);
  }
  static leftShift(i, _) {
    return 0 === _.length || 0 === i.length ? i : _.sign ? JSBI.__rightShiftByAbsolute(i, _) : JSBI.__leftShiftByAbsolute(i, _);
  }
  static signedRightShift(i, _) {
    return 0 === _.length || 0 === i.length ? i : _.sign ? JSBI.__leftShiftByAbsolute(i, _) : JSBI.__rightShiftByAbsolute(i, _);
  }
  static unsignedRightShift() {
    throw new TypeError("BigInts have no unsigned right shift; use >> instead");
  }
  static lessThan(i, _) {
    return 0 > JSBI.__compareToBigInt(i, _);
  }
  static lessThanOrEqual(i, _) {
    return 0 >= JSBI.__compareToBigInt(i, _);
  }
  static greaterThan(i, _) {
    return 0 < JSBI.__compareToBigInt(i, _);
  }
  static greaterThanOrEqual(i, _) {
    return 0 <= JSBI.__compareToBigInt(i, _);
  }
  static equal(_, t) {
    if (_.sign !== t.sign)
      return false;
    if (_.length !== t.length)
      return false;
    for (let e = 0; e < _.length; e++)
      if (_.__digit(e) !== t.__digit(e))
        return false;
    return true;
  }
  static notEqual(i, _) {
    return !JSBI.equal(i, _);
  }
  static bitwiseAnd(i, _) {
    var t = Math.max;
    if (!i.sign && !_.sign)
      return JSBI.__absoluteAnd(i, _).__trim();
    if (i.sign && _.sign) {
      const e = t(i.length, _.length) + 1;
      let n = JSBI.__absoluteSubOne(i, e);
      const g = JSBI.__absoluteSubOne(_);
      return n = JSBI.__absoluteOr(n, g, n), JSBI.__absoluteAddOne(n, true, n).__trim();
    }
    return i.sign && ([i, _] = [_, i]), JSBI.__absoluteAndNot(i, JSBI.__absoluteSubOne(_)).__trim();
  }
  static bitwiseXor(i, _) {
    var t = Math.max;
    if (!i.sign && !_.sign)
      return JSBI.__absoluteXor(i, _).__trim();
    if (i.sign && _.sign) {
      const e2 = t(i.length, _.length), n2 = JSBI.__absoluteSubOne(i, e2), g = JSBI.__absoluteSubOne(_);
      return JSBI.__absoluteXor(n2, g, n2).__trim();
    }
    const e = t(i.length, _.length) + 1;
    i.sign && ([i, _] = [_, i]);
    let n = JSBI.__absoluteSubOne(_, e);
    return n = JSBI.__absoluteXor(n, i, n), JSBI.__absoluteAddOne(n, true, n).__trim();
  }
  static bitwiseOr(i, _) {
    var t = Math.max;
    const e = t(i.length, _.length);
    if (!i.sign && !_.sign)
      return JSBI.__absoluteOr(i, _).__trim();
    if (i.sign && _.sign) {
      let t2 = JSBI.__absoluteSubOne(i, e);
      const n2 = JSBI.__absoluteSubOne(_);
      return t2 = JSBI.__absoluteAnd(t2, n2, t2), JSBI.__absoluteAddOne(t2, true, t2).__trim();
    }
    i.sign && ([i, _] = [_, i]);
    let n = JSBI.__absoluteSubOne(_, e);
    return n = JSBI.__absoluteAndNot(n, i, n), JSBI.__absoluteAddOne(n, true, n).__trim();
  }
  static asIntN(_, t) {
    var i = Math.floor;
    if (0 === t.length)
      return t;
    if (_ = i(_), 0 > _)
      throw new RangeError("Invalid value: not (convertible to) a safe integer");
    if (0 === _)
      return JSBI.__zero();
    if (_ >= JSBI.__kMaxLengthBits)
      return t;
    const e = 0 | (_ + 29) / 30;
    if (t.length < e)
      return t;
    const g = t.__unsignedDigit(e - 1), o = 1 << (_ - 1) % 30;
    if (t.length === e && g < o)
      return t;
    if (!((g & o) === o))
      return JSBI.__truncateToNBits(_, t);
    if (!t.sign)
      return JSBI.__truncateAndSubFromPowerOfTwo(_, t, true);
    if (0 == (g & o - 1)) {
      for (let n = e - 2; 0 <= n; n--)
        if (0 !== t.__digit(n))
          return JSBI.__truncateAndSubFromPowerOfTwo(_, t, false);
      return t.length === e && g === o ? t : JSBI.__truncateToNBits(_, t);
    }
    return JSBI.__truncateAndSubFromPowerOfTwo(_, t, false);
  }
  static asUintN(i, _) {
    var t = Math.floor;
    if (0 === _.length)
      return _;
    if (i = t(i), 0 > i)
      throw new RangeError("Invalid value: not (convertible to) a safe integer");
    if (0 === i)
      return JSBI.__zero();
    if (_.sign) {
      if (i > JSBI.__kMaxLengthBits)
        throw new RangeError("BigInt too big");
      return JSBI.__truncateAndSubFromPowerOfTwo(i, _, false);
    }
    if (i >= JSBI.__kMaxLengthBits)
      return _;
    const e = 0 | (i + 29) / 30;
    if (_.length < e)
      return _;
    const g = i % 30;
    if (_.length == e) {
      if (0 === g)
        return _;
      const i2 = _.__digit(e - 1);
      if (0 == i2 >>> g)
        return _;
    }
    return JSBI.__truncateToNBits(i, _);
  }
  static ADD(i, _) {
    if (i = JSBI.__toPrimitive(i), _ = JSBI.__toPrimitive(_), "string" == typeof i)
      return "string" != typeof _ && (_ = _.toString()), i + _;
    if ("string" == typeof _)
      return i.toString() + _;
    if (i = JSBI.__toNumeric(i), _ = JSBI.__toNumeric(_), JSBI.__isBigInt(i) && JSBI.__isBigInt(_))
      return JSBI.add(i, _);
    if ("number" == typeof i && "number" == typeof _)
      return i + _;
    throw new TypeError("Cannot mix BigInt and other types, use explicit conversions");
  }
  static LT(i, _) {
    return JSBI.__compare(i, _, 0);
  }
  static LE(i, _) {
    return JSBI.__compare(i, _, 1);
  }
  static GT(i, _) {
    return JSBI.__compare(i, _, 2);
  }
  static GE(i, _) {
    return JSBI.__compare(i, _, 3);
  }
  static EQ(i, _) {
    for (; ; ) {
      if (JSBI.__isBigInt(i))
        return JSBI.__isBigInt(_) ? JSBI.equal(i, _) : JSBI.EQ(_, i);
      if ("number" == typeof i) {
        if (JSBI.__isBigInt(_))
          return JSBI.__equalToNumber(_, i);
        if ("object" != typeof _)
          return i == _;
        _ = JSBI.__toPrimitive(_);
      } else if ("string" == typeof i) {
        if (JSBI.__isBigInt(_))
          return i = JSBI.__fromString(i), null !== i && JSBI.equal(i, _);
        if ("object" != typeof _)
          return i == _;
        _ = JSBI.__toPrimitive(_);
      } else if ("boolean" == typeof i) {
        if (JSBI.__isBigInt(_))
          return JSBI.__equalToNumber(_, +i);
        if ("object" != typeof _)
          return i == _;
        _ = JSBI.__toPrimitive(_);
      } else if ("symbol" == typeof i) {
        if (JSBI.__isBigInt(_))
          return false;
        if ("object" != typeof _)
          return i == _;
        _ = JSBI.__toPrimitive(_);
      } else if ("object" == typeof i) {
        if ("object" == typeof _ && _.constructor !== JSBI)
          return i == _;
        i = JSBI.__toPrimitive(i);
      } else
        return i == _;
    }
  }
  static NE(i, _) {
    return !JSBI.EQ(i, _);
  }
  static __zero() {
    return new JSBI(0, false);
  }
  static __oneDigit(i, _) {
    const t = new JSBI(1, _);
    return t.__setDigit(0, i), t;
  }
  __copy() {
    const _ = new JSBI(this.length, this.sign);
    for (let t = 0; t < this.length; t++)
      _[t] = this[t];
    return _;
  }
  __trim() {
    let i = this.length, _ = this[i - 1];
    for (; 0 === _; )
      i--, _ = this[i - 1], this.pop();
    return 0 === i && (this.sign = false), this;
  }
  __initializeDigits() {
    for (let _ = 0; _ < this.length; _++)
      this[_] = 0;
  }
  static __decideRounding(i, _, t, e) {
    if (0 < _)
      return -1;
    let n;
    if (0 > _)
      n = -_ - 1;
    else {
      if (0 === t)
        return -1;
      t--, e = i.__digit(t), n = 29;
    }
    let g = 1 << n;
    if (0 == (e & g))
      return -1;
    if (g -= 1, 0 != (e & g))
      return 1;
    for (; 0 < t; )
      if (t--, 0 !== i.__digit(t))
        return 1;
    return 0;
  }
  static __fromDouble(i) {
    JSBI.__kBitConversionDouble[0] = i;
    const _ = 2047 & JSBI.__kBitConversionInts[1] >>> 20, t = _ - 1023, e = (0 | t / 30) + 1, n = new JSBI(e, 0 > i);
    let g = 1048575 & JSBI.__kBitConversionInts[1] | 1048576, o = JSBI.__kBitConversionInts[0];
    const s = 20, l = t % 30;
    let r, a = 0;
    if (l < 20) {
      const i2 = s - l;
      a = i2 + 32, r = g >>> i2, g = g << 32 - i2 | o >>> i2, o <<= 32 - i2;
    } else if (l === 20)
      a = 32, r = g, g = o, o = 0;
    else {
      const i2 = l - s;
      a = 32 - i2, r = g << i2 | o >>> 32 - i2, g = o << i2, o = 0;
    }
    n.__setDigit(e - 1, r);
    for (let _2 = e - 2; 0 <= _2; _2--)
      0 < a ? (a -= 30, r = g >>> 2, g = g << 30 | o >>> 2, o <<= 30) : r = 0, n.__setDigit(_2, r);
    return n.__trim();
  }
  static __isWhitespace(i) {
    return !!(13 >= i && 9 <= i) || (159 >= i ? 32 == i : 131071 >= i ? 160 == i || 5760 == i : 196607 >= i ? (i &= 131071, 10 >= i || 40 == i || 41 == i || 47 == i || 95 == i || 4096 == i) : 65279 == i);
  }
  static __fromString(i, _ = 0) {
    let t = 0;
    const e = i.length;
    let n = 0;
    if (n === e)
      return JSBI.__zero();
    let g = i.charCodeAt(n);
    for (; JSBI.__isWhitespace(g); ) {
      if (++n === e)
        return JSBI.__zero();
      g = i.charCodeAt(n);
    }
    if (43 === g) {
      if (++n === e)
        return null;
      g = i.charCodeAt(n), t = 1;
    } else if (45 === g) {
      if (++n === e)
        return null;
      g = i.charCodeAt(n), t = -1;
    }
    if (0 === _) {
      if (_ = 10, 48 === g) {
        if (++n === e)
          return JSBI.__zero();
        if (g = i.charCodeAt(n), 88 === g || 120 === g) {
          if (_ = 16, ++n === e)
            return null;
          g = i.charCodeAt(n);
        } else if (79 === g || 111 === g) {
          if (_ = 8, ++n === e)
            return null;
          g = i.charCodeAt(n);
        } else if (66 === g || 98 === g) {
          if (_ = 2, ++n === e)
            return null;
          g = i.charCodeAt(n);
        }
      }
    } else if (16 === _ && 48 === g) {
      if (++n === e)
        return JSBI.__zero();
      if (g = i.charCodeAt(n), 88 === g || 120 === g) {
        if (++n === e)
          return null;
        g = i.charCodeAt(n);
      }
    }
    if (0 != t && 10 !== _)
      return null;
    for (; 48 === g; ) {
      if (++n === e)
        return JSBI.__zero();
      g = i.charCodeAt(n);
    }
    const o = e - n;
    let s = JSBI.__kMaxBitsPerChar[_], l = JSBI.__kBitsPerCharTableMultiplier - 1;
    if (o > 1073741824 / s)
      return null;
    const r = s * o + l >>> JSBI.__kBitsPerCharTableShift, a = new JSBI(0 | (r + 29) / 30, false), u = 10 > _ ? _ : 10, h = 10 < _ ? _ - 10 : 0;
    if (0 == (_ & _ - 1)) {
      s >>= JSBI.__kBitsPerCharTableShift;
      const _2 = [], t2 = [];
      let o2 = false;
      do {
        let l2 = 0, r2 = 0;
        for (; ; ) {
          let _3;
          if (g - 48 >>> 0 < u)
            _3 = g - 48;
          else if ((32 | g) - 97 >>> 0 < h)
            _3 = (32 | g) - 87;
          else {
            o2 = true;
            break;
          }
          if (r2 += s, l2 = l2 << s | _3, ++n === e) {
            o2 = true;
            break;
          }
          if (g = i.charCodeAt(n), 30 < r2 + s)
            break;
        }
        _2.push(l2), t2.push(r2);
      } while (!o2);
      JSBI.__fillFromParts(a, _2, t2);
    } else {
      a.__initializeDigits();
      let t2 = false, o2 = 0;
      do {
        let r2 = 0, b = 1;
        for (; ; ) {
          let s2;
          if (g - 48 >>> 0 < u)
            s2 = g - 48;
          else if ((32 | g) - 97 >>> 0 < h)
            s2 = (32 | g) - 87;
          else {
            t2 = true;
            break;
          }
          const l2 = b * _;
          if (1073741823 < l2)
            break;
          if (b = l2, r2 = r2 * _ + s2, o2++, ++n === e) {
            t2 = true;
            break;
          }
          g = i.charCodeAt(n);
        }
        l = 30 * JSBI.__kBitsPerCharTableMultiplier - 1;
        const D = 0 | (s * o2 + l >>> JSBI.__kBitsPerCharTableShift) / 30;
        a.__inplaceMultiplyAdd(b, r2, D);
      } while (!t2);
    }
    if (n !== e) {
      if (!JSBI.__isWhitespace(g))
        return null;
      for (n++; n < e; n++)
        if (g = i.charCodeAt(n), !JSBI.__isWhitespace(g))
          return null;
    }
    return a.sign = -1 == t, a.__trim();
  }
  static __fillFromParts(_, t, e) {
    let n = 0, g = 0, o = 0;
    for (let s = t.length - 1; 0 <= s; s--) {
      const i = t[s], l = e[s];
      g |= i << o, o += l, 30 === o ? (_.__setDigit(n++, g), o = 0, g = 0) : 30 < o && (_.__setDigit(n++, 1073741823 & g), o -= 30, g = i >>> l - o);
    }
    if (0 !== g) {
      if (n >= _.length)
        throw new Error("implementation bug");
      _.__setDigit(n++, g);
    }
    for (; n < _.length; n++)
      _.__setDigit(n, 0);
  }
  static __toStringBasePowerOfTwo(_, i) {
    const t = _.length;
    let e = i - 1;
    e = (85 & e >>> 1) + (85 & e), e = (51 & e >>> 2) + (51 & e), e = (15 & e >>> 4) + (15 & e);
    const n = e, g = i - 1, o = _.__digit(t - 1), s = JSBI.__clz30(o);
    let l = 0 | (30 * t - s + n - 1) / n;
    if (_.sign && l++, 268435456 < l)
      throw new Error("string too long");
    const r = Array(l);
    let a = l - 1, u = 0, d = 0;
    for (let e2 = 0; e2 < t - 1; e2++) {
      const i2 = _.__digit(e2), t2 = (u | i2 << d) & g;
      r[a--] = JSBI.__kConversionChars[t2];
      const o2 = n - d;
      for (u = i2 >>> o2, d = 30 - o2; d >= n; )
        r[a--] = JSBI.__kConversionChars[u & g], u >>>= n, d -= n;
    }
    const h = (u | o << d) & g;
    for (r[a--] = JSBI.__kConversionChars[h], u = o >>> n - d; 0 !== u; )
      r[a--] = JSBI.__kConversionChars[u & g], u >>>= n;
    if (_.sign && (r[a--] = "-"), -1 != a)
      throw new Error("implementation bug");
    return r.join("");
  }
  static __toStringGeneric(_, i, t) {
    const e = _.length;
    if (0 === e)
      return "";
    if (1 === e) {
      let e2 = _.__unsignedDigit(0).toString(i);
      return false === t && _.sign && (e2 = "-" + e2), e2;
    }
    const n = 30 * e - JSBI.__clz30(_.__digit(e - 1)), g = JSBI.__kMaxBitsPerChar[i], o = g - 1;
    let s = n * JSBI.__kBitsPerCharTableMultiplier;
    s += o - 1, s = 0 | s / o;
    const l = s + 1 >> 1, r = JSBI.exponentiate(JSBI.__oneDigit(i, false), JSBI.__oneDigit(l, false));
    let a, u;
    const d = r.__unsignedDigit(0);
    if (1 === r.length && 32767 >= d) {
      a = new JSBI(_.length, false), a.__initializeDigits();
      let t2 = 0;
      for (let e2 = 2 * _.length - 1; 0 <= e2; e2--) {
        const i2 = t2 << 15 | _.__halfDigit(e2);
        a.__setHalfDigit(e2, 0 | i2 / d), t2 = 0 | i2 % d;
      }
      u = t2.toString(i);
    } else {
      const t2 = JSBI.__absoluteDivLarge(_, r, true, true);
      a = t2.quotient;
      const e2 = t2.remainder.__trim();
      u = JSBI.__toStringGeneric(e2, i, true);
    }
    a.__trim();
    let h = JSBI.__toStringGeneric(a, i, true);
    for (; u.length < l; )
      u = "0" + u;
    return false === t && _.sign && (h = "-" + h), h + u;
  }
  static __unequalSign(i) {
    return i ? -1 : 1;
  }
  static __absoluteGreater(i) {
    return i ? -1 : 1;
  }
  static __absoluteLess(i) {
    return i ? 1 : -1;
  }
  static __compareToBigInt(i, _) {
    const t = i.sign;
    if (t !== _.sign)
      return JSBI.__unequalSign(t);
    const e = JSBI.__absoluteCompare(i, _);
    return 0 < e ? JSBI.__absoluteGreater(t) : 0 > e ? JSBI.__absoluteLess(t) : 0;
  }
  static __compareToNumber(i, _) {
    if (JSBI.__isOneDigitInt(_)) {
      const t = i.sign, e = 0 > _;
      if (t !== e)
        return JSBI.__unequalSign(t);
      if (0 === i.length) {
        if (e)
          throw new Error("implementation bug");
        return 0 === _ ? 0 : -1;
      }
      if (1 < i.length)
        return JSBI.__absoluteGreater(t);
      const n = Math.abs(_), g = i.__unsignedDigit(0);
      return g > n ? JSBI.__absoluteGreater(t) : g < n ? JSBI.__absoluteLess(t) : 0;
    }
    return JSBI.__compareToDouble(i, _);
  }
  static __compareToDouble(i, _) {
    if (_ !== _)
      return _;
    if (_ === 1 / 0)
      return -1;
    if (_ === -Infinity)
      return 1;
    const t = i.sign;
    if (t !== 0 > _)
      return JSBI.__unequalSign(t);
    if (0 === _)
      throw new Error("implementation bug: should be handled elsewhere");
    if (0 === i.length)
      return -1;
    JSBI.__kBitConversionDouble[0] = _;
    const e = 2047 & JSBI.__kBitConversionInts[1] >>> 20;
    if (2047 == e)
      throw new Error("implementation bug: handled elsewhere");
    const n = e - 1023;
    if (0 > n)
      return JSBI.__absoluteGreater(t);
    const g = i.length;
    let o = i.__digit(g - 1);
    const s = JSBI.__clz30(o), l = 30 * g - s, r = n + 1;
    if (l < r)
      return JSBI.__absoluteLess(t);
    if (l > r)
      return JSBI.__absoluteGreater(t);
    let a = 1048576 | 1048575 & JSBI.__kBitConversionInts[1], u = JSBI.__kBitConversionInts[0];
    const d = 20, h = 29 - s;
    if (h !== (0 | (l - 1) % 30))
      throw new Error("implementation bug");
    let m, b = 0;
    if (20 > h) {
      const i2 = d - h;
      b = i2 + 32, m = a >>> i2, a = a << 32 - i2 | u >>> i2, u <<= 32 - i2;
    } else if (20 === h)
      b = 32, m = a, a = u, u = 0;
    else {
      const i2 = h - d;
      b = 32 - i2, m = a << i2 | u >>> 32 - i2, a = u << i2, u = 0;
    }
    if (o >>>= 0, m >>>= 0, o > m)
      return JSBI.__absoluteGreater(t);
    if (o < m)
      return JSBI.__absoluteLess(t);
    for (let e2 = g - 2; 0 <= e2; e2--) {
      0 < b ? (b -= 30, m = a >>> 2, a = a << 30 | u >>> 2, u <<= 30) : m = 0;
      const _2 = i.__unsignedDigit(e2);
      if (_2 > m)
        return JSBI.__absoluteGreater(t);
      if (_2 < m)
        return JSBI.__absoluteLess(t);
    }
    if (0 !== a || 0 !== u) {
      if (0 === b)
        throw new Error("implementation bug");
      return JSBI.__absoluteLess(t);
    }
    return 0;
  }
  static __equalToNumber(i, _) {
    var t = Math.abs;
    return JSBI.__isOneDigitInt(_) ? 0 === _ ? 0 === i.length : 1 === i.length && i.sign === 0 > _ && i.__unsignedDigit(0) === t(_) : 0 === JSBI.__compareToDouble(i, _);
  }
  static __comparisonResultToBool(i, _) {
    return 0 === _ ? 0 > i : 1 === _ ? 0 >= i : 2 === _ ? 0 < i : 3 === _ ? 0 <= i : void 0;
  }
  static __compare(i, _, t) {
    if (i = JSBI.__toPrimitive(i), _ = JSBI.__toPrimitive(_), "string" == typeof i && "string" == typeof _)
      switch (t) {
        case 0:
          return i < _;
        case 1:
          return i <= _;
        case 2:
          return i > _;
        case 3:
          return i >= _;
      }
    if (JSBI.__isBigInt(i) && "string" == typeof _)
      return _ = JSBI.__fromString(_), null !== _ && JSBI.__comparisonResultToBool(JSBI.__compareToBigInt(i, _), t);
    if ("string" == typeof i && JSBI.__isBigInt(_))
      return i = JSBI.__fromString(i), null !== i && JSBI.__comparisonResultToBool(JSBI.__compareToBigInt(i, _), t);
    if (i = JSBI.__toNumeric(i), _ = JSBI.__toNumeric(_), JSBI.__isBigInt(i)) {
      if (JSBI.__isBigInt(_))
        return JSBI.__comparisonResultToBool(JSBI.__compareToBigInt(i, _), t);
      if ("number" != typeof _)
        throw new Error("implementation bug");
      return JSBI.__comparisonResultToBool(JSBI.__compareToNumber(i, _), t);
    }
    if ("number" != typeof i)
      throw new Error("implementation bug");
    if (JSBI.__isBigInt(_))
      return JSBI.__comparisonResultToBool(JSBI.__compareToNumber(_, i), 2 ^ t);
    if ("number" != typeof _)
      throw new Error("implementation bug");
    return 0 === t ? i < _ : 1 === t ? i <= _ : 2 === t ? i > _ : 3 === t ? i >= _ : void 0;
  }
  __clzmsd() {
    return JSBI.__clz30(this.__digit(this.length - 1));
  }
  static __absoluteAdd(_, t, e) {
    if (_.length < t.length)
      return JSBI.__absoluteAdd(t, _, e);
    if (0 === _.length)
      return _;
    if (0 === t.length)
      return _.sign === e ? _ : JSBI.unaryMinus(_);
    let n = _.length;
    (0 === _.__clzmsd() || t.length === _.length && 0 === t.__clzmsd()) && n++;
    const g = new JSBI(n, e);
    let o = 0, s = 0;
    for (; s < t.length; s++) {
      const i = _.__digit(s) + t.__digit(s) + o;
      o = i >>> 30, g.__setDigit(s, 1073741823 & i);
    }
    for (; s < _.length; s++) {
      const i = _.__digit(s) + o;
      o = i >>> 30, g.__setDigit(s, 1073741823 & i);
    }
    return s < g.length && g.__setDigit(s, o), g.__trim();
  }
  static __absoluteSub(_, t, e) {
    if (0 === _.length)
      return _;
    if (0 === t.length)
      return _.sign === e ? _ : JSBI.unaryMinus(_);
    const n = new JSBI(_.length, e);
    let g = 0, o = 0;
    for (; o < t.length; o++) {
      const i = _.__digit(o) - t.__digit(o) - g;
      g = 1 & i >>> 30, n.__setDigit(o, 1073741823 & i);
    }
    for (; o < _.length; o++) {
      const i = _.__digit(o) - g;
      g = 1 & i >>> 30, n.__setDigit(o, 1073741823 & i);
    }
    return n.__trim();
  }
  static __absoluteAddOne(_, i, t = null) {
    const e = _.length;
    null === t ? t = new JSBI(e, i) : t.sign = i;
    let n = 1;
    for (let g = 0; g < e; g++) {
      const i2 = _.__digit(g) + n;
      n = i2 >>> 30, t.__setDigit(g, 1073741823 & i2);
    }
    return 0 != n && t.__setDigitGrow(e, 1), t;
  }
  static __absoluteSubOne(_, t) {
    const e = _.length;
    t = t || e;
    const n = new JSBI(t, false);
    let g = 1;
    for (let o = 0; o < e; o++) {
      const i = _.__digit(o) - g;
      g = 1 & i >>> 30, n.__setDigit(o, 1073741823 & i);
    }
    if (0 != g)
      throw new Error("implementation bug");
    for (let g2 = e; g2 < t; g2++)
      n.__setDigit(g2, 0);
    return n;
  }
  static __absoluteAnd(_, t, e = null) {
    let n = _.length, g = t.length, o = g;
    if (n < g) {
      o = n;
      const i = _, e2 = n;
      _ = t, n = g, t = i, g = e2;
    }
    let s = o;
    null === e ? e = new JSBI(s, false) : s = e.length;
    let l = 0;
    for (; l < o; l++)
      e.__setDigit(l, _.__digit(l) & t.__digit(l));
    for (; l < s; l++)
      e.__setDigit(l, 0);
    return e;
  }
  static __absoluteAndNot(_, t, e = null) {
    const n = _.length, g = t.length;
    let o = g;
    n < g && (o = n);
    let s = n;
    null === e ? e = new JSBI(s, false) : s = e.length;
    let l = 0;
    for (; l < o; l++)
      e.__setDigit(l, _.__digit(l) & ~t.__digit(l));
    for (; l < n; l++)
      e.__setDigit(l, _.__digit(l));
    for (; l < s; l++)
      e.__setDigit(l, 0);
    return e;
  }
  static __absoluteOr(_, t, e = null) {
    let n = _.length, g = t.length, o = g;
    if (n < g) {
      o = n;
      const i = _, e2 = n;
      _ = t, n = g, t = i, g = e2;
    }
    let s = n;
    null === e ? e = new JSBI(s, false) : s = e.length;
    let l = 0;
    for (; l < o; l++)
      e.__setDigit(l, _.__digit(l) | t.__digit(l));
    for (; l < n; l++)
      e.__setDigit(l, _.__digit(l));
    for (; l < s; l++)
      e.__setDigit(l, 0);
    return e;
  }
  static __absoluteXor(_, t, e = null) {
    let n = _.length, g = t.length, o = g;
    if (n < g) {
      o = n;
      const i = _, e2 = n;
      _ = t, n = g, t = i, g = e2;
    }
    let s = n;
    null === e ? e = new JSBI(s, false) : s = e.length;
    let l = 0;
    for (; l < o; l++)
      e.__setDigit(l, _.__digit(l) ^ t.__digit(l));
    for (; l < n; l++)
      e.__setDigit(l, _.__digit(l));
    for (; l < s; l++)
      e.__setDigit(l, 0);
    return e;
  }
  static __absoluteCompare(_, t) {
    const e = _.length - t.length;
    if (0 != e)
      return e;
    let n = _.length - 1;
    for (; 0 <= n && _.__digit(n) === t.__digit(n); )
      n--;
    return 0 > n ? 0 : _.__unsignedDigit(n) > t.__unsignedDigit(n) ? 1 : -1;
  }
  static __multiplyAccumulate(_, t, e, n) {
    if (0 === t)
      return;
    const g = 32767 & t, o = t >>> 15;
    let s = 0, l = 0;
    for (let r, a = 0; a < _.length; a++, n++) {
      r = e.__digit(n);
      const i = _.__digit(a), t2 = 32767 & i, u = i >>> 15, d = JSBI.__imul(t2, g), h = JSBI.__imul(t2, o), m = JSBI.__imul(u, g), b = JSBI.__imul(u, o);
      r += l + d + s, s = r >>> 30, r &= 1073741823, r += ((32767 & h) << 15) + ((32767 & m) << 15), s += r >>> 30, l = b + (h >>> 15) + (m >>> 15), e.__setDigit(n, 1073741823 & r);
    }
    for (; 0 != s || 0 !== l; n++) {
      let i = e.__digit(n);
      i += s + l, l = 0, s = i >>> 30, e.__setDigit(n, 1073741823 & i);
    }
  }
  static __internalMultiplyAdd(_, t, e, g, o) {
    let s = e, l = 0;
    for (let n = 0; n < g; n++) {
      const i = _.__digit(n), e2 = JSBI.__imul(32767 & i, t), g2 = JSBI.__imul(i >>> 15, t), a = e2 + ((32767 & g2) << 15) + l + s;
      s = a >>> 30, l = g2 >>> 15, o.__setDigit(n, 1073741823 & a);
    }
    if (o.length > g)
      for (o.__setDigit(g++, s + l); g < o.length; )
        o.__setDigit(g++, 0);
    else if (0 !== s + l)
      throw new Error("implementation bug");
  }
  __inplaceMultiplyAdd(i, _, t) {
    t > this.length && (t = this.length);
    const e = 32767 & i, n = i >>> 15;
    let g = 0, o = _;
    for (let s = 0; s < t; s++) {
      const i2 = this.__digit(s), _2 = 32767 & i2, t2 = i2 >>> 15, l = JSBI.__imul(_2, e), r = JSBI.__imul(_2, n), a = JSBI.__imul(t2, e), u = JSBI.__imul(t2, n);
      let d = o + l + g;
      g = d >>> 30, d &= 1073741823, d += ((32767 & r) << 15) + ((32767 & a) << 15), g += d >>> 30, o = u + (r >>> 15) + (a >>> 15), this.__setDigit(s, 1073741823 & d);
    }
    if (0 != g || 0 !== o)
      throw new Error("implementation bug");
  }
  static __absoluteDivSmall(_, t, e = null) {
    null === e && (e = new JSBI(_.length, false));
    let n = 0;
    for (let g, o = 2 * _.length - 1; 0 <= o; o -= 2) {
      g = (n << 15 | _.__halfDigit(o)) >>> 0;
      const i = 0 | g / t;
      n = 0 | g % t, g = (n << 15 | _.__halfDigit(o - 1)) >>> 0;
      const s = 0 | g / t;
      n = 0 | g % t, e.__setDigit(o >>> 1, i << 15 | s);
    }
    return e;
  }
  static __absoluteModSmall(_, t) {
    let e = 0;
    for (let n = 2 * _.length - 1; 0 <= n; n--) {
      const i = (e << 15 | _.__halfDigit(n)) >>> 0;
      e = 0 | i % t;
    }
    return e;
  }
  static __absoluteDivLarge(i, _, t, e) {
    const g = _.__halfDigitLength(), n = _.length, o = i.__halfDigitLength() - g;
    let s = null;
    t && (s = new JSBI(o + 2 >>> 1, false), s.__initializeDigits());
    const l = new JSBI(g + 2 >>> 1, false);
    l.__initializeDigits();
    const r = JSBI.__clz15(_.__halfDigit(g - 1));
    0 < r && (_ = JSBI.__specialLeftShift(_, r, 0));
    const a = JSBI.__specialLeftShift(i, r, 1), u = _.__halfDigit(g - 1);
    let d = 0;
    for (let r2, h = o; 0 <= h; h--) {
      r2 = 32767;
      const i2 = a.__halfDigit(h + g);
      if (i2 !== u) {
        const t2 = (i2 << 15 | a.__halfDigit(h + g - 1)) >>> 0;
        r2 = 0 | t2 / u;
        let e3 = 0 | t2 % u;
        const n2 = _.__halfDigit(g - 2), o2 = a.__halfDigit(h + g - 2);
        for (; JSBI.__imul(r2, n2) >>> 0 > (e3 << 16 | o2) >>> 0 && (r2--, e3 += u, !(32767 < e3)); )
          ;
      }
      JSBI.__internalMultiplyAdd(_, r2, 0, n, l);
      let e2 = a.__inplaceSub(l, h, g + 1);
      0 !== e2 && (e2 = a.__inplaceAdd(_, h, g), a.__setHalfDigit(h + g, 32767 & a.__halfDigit(h + g) + e2), r2--), t && (1 & h ? d = r2 << 15 : s.__setDigit(h >>> 1, d | r2));
    }
    if (e)
      return a.__inplaceRightShift(r), t ? { quotient: s, remainder: a } : a;
    if (t)
      return s;
    throw new Error("unreachable");
  }
  static __clz15(i) {
    return JSBI.__clz30(i) - 15;
  }
  __inplaceAdd(_, t, e) {
    let n = 0;
    for (let g = 0; g < e; g++) {
      const i = this.__halfDigit(t + g) + _.__halfDigit(g) + n;
      n = i >>> 15, this.__setHalfDigit(t + g, 32767 & i);
    }
    return n;
  }
  __inplaceSub(_, t, e) {
    let n = 0;
    if (1 & t) {
      t >>= 1;
      let g = this.__digit(t), o = 32767 & g, s = 0;
      for (; s < e - 1 >>> 1; s++) {
        const i2 = _.__digit(s), e2 = (g >>> 15) - (32767 & i2) - n;
        n = 1 & e2 >>> 15, this.__setDigit(t + s, (32767 & e2) << 15 | 32767 & o), g = this.__digit(t + s + 1), o = (32767 & g) - (i2 >>> 15) - n, n = 1 & o >>> 15;
      }
      const i = _.__digit(s), l = (g >>> 15) - (32767 & i) - n;
      n = 1 & l >>> 15, this.__setDigit(t + s, (32767 & l) << 15 | 32767 & o);
      if (t + s + 1 >= this.length)
        throw new RangeError("out of bounds");
      0 == (1 & e) && (g = this.__digit(t + s + 1), o = (32767 & g) - (i >>> 15) - n, n = 1 & o >>> 15, this.__setDigit(t + _.length, 1073709056 & g | 32767 & o));
    } else {
      t >>= 1;
      let g = 0;
      for (; g < _.length - 1; g++) {
        const i2 = this.__digit(t + g), e2 = _.__digit(g), o2 = (32767 & i2) - (32767 & e2) - n;
        n = 1 & o2 >>> 15;
        const s2 = (i2 >>> 15) - (e2 >>> 15) - n;
        n = 1 & s2 >>> 15, this.__setDigit(t + g, (32767 & s2) << 15 | 32767 & o2);
      }
      const i = this.__digit(t + g), o = _.__digit(g), s = (32767 & i) - (32767 & o) - n;
      n = 1 & s >>> 15;
      let l = 0;
      0 == (1 & e) && (l = (i >>> 15) - (o >>> 15) - n, n = 1 & l >>> 15), this.__setDigit(t + g, (32767 & l) << 15 | 32767 & s);
    }
    return n;
  }
  __inplaceRightShift(_) {
    if (0 === _)
      return;
    let t = this.__digit(0) >>> _;
    const e = this.length - 1;
    for (let n = 0; n < e; n++) {
      const i = this.__digit(n + 1);
      this.__setDigit(n, 1073741823 & i << 30 - _ | t), t = i >>> _;
    }
    this.__setDigit(e, t);
  }
  static __specialLeftShift(_, t, e) {
    const g = _.length, n = new JSBI(g + e, false);
    if (0 === t) {
      for (let t2 = 0; t2 < g; t2++)
        n.__setDigit(t2, _.__digit(t2));
      return 0 < e && n.__setDigit(g, 0), n;
    }
    let o = 0;
    for (let s = 0; s < g; s++) {
      const i = _.__digit(s);
      n.__setDigit(s, 1073741823 & i << t | o), o = i >>> 30 - t;
    }
    return 0 < e && n.__setDigit(g, o), n;
  }
  static __leftShiftByAbsolute(_, i) {
    const t = JSBI.__toShiftAmount(i);
    if (0 > t)
      throw new RangeError("BigInt too big");
    const e = 0 | t / 30, n = t % 30, g = _.length, o = 0 !== n && 0 != _.__digit(g - 1) >>> 30 - n, s = g + e + (o ? 1 : 0), l = new JSBI(s, _.sign);
    if (0 === n) {
      let t2 = 0;
      for (; t2 < e; t2++)
        l.__setDigit(t2, 0);
      for (; t2 < s; t2++)
        l.__setDigit(t2, _.__digit(t2 - e));
    } else {
      let t2 = 0;
      for (let _2 = 0; _2 < e; _2++)
        l.__setDigit(_2, 0);
      for (let o2 = 0; o2 < g; o2++) {
        const i2 = _.__digit(o2);
        l.__setDigit(o2 + e, 1073741823 & i2 << n | t2), t2 = i2 >>> 30 - n;
      }
      if (o)
        l.__setDigit(g + e, t2);
      else if (0 !== t2)
        throw new Error("implementation bug");
    }
    return l.__trim();
  }
  static __rightShiftByAbsolute(_, i) {
    const t = _.length, e = _.sign, n = JSBI.__toShiftAmount(i);
    if (0 > n)
      return JSBI.__rightShiftByMaximum(e);
    const g = 0 | n / 30, o = n % 30;
    let s = t - g;
    if (0 >= s)
      return JSBI.__rightShiftByMaximum(e);
    let l = false;
    if (e) {
      if (0 != (_.__digit(g) & (1 << o) - 1))
        l = true;
      else
        for (let t2 = 0; t2 < g; t2++)
          if (0 !== _.__digit(t2)) {
            l = true;
            break;
          }
    }
    if (l && 0 === o) {
      const i2 = _.__digit(t - 1);
      0 == ~i2 && s++;
    }
    let r = new JSBI(s, e);
    if (0 === o) {
      r.__setDigit(s - 1, 0);
      for (let e2 = g; e2 < t; e2++)
        r.__setDigit(e2 - g, _.__digit(e2));
    } else {
      let e2 = _.__digit(g) >>> o;
      const n2 = t - g - 1;
      for (let t2 = 0; t2 < n2; t2++) {
        const i2 = _.__digit(t2 + g + 1);
        r.__setDigit(t2, 1073741823 & i2 << 30 - o | e2), e2 = i2 >>> o;
      }
      r.__setDigit(n2, e2);
    }
    return l && (r = JSBI.__absoluteAddOne(r, true, r)), r.__trim();
  }
  static __rightShiftByMaximum(i) {
    return i ? JSBI.__oneDigit(1, true) : JSBI.__zero();
  }
  static __toShiftAmount(i) {
    if (1 < i.length)
      return -1;
    const _ = i.__unsignedDigit(0);
    return _ > JSBI.__kMaxLengthBits ? -1 : _;
  }
  static __toPrimitive(i, _ = "default") {
    if ("object" != typeof i)
      return i;
    if (i.constructor === JSBI)
      return i;
    if ("undefined" != typeof Symbol && "symbol" == typeof Symbol.toPrimitive) {
      const t2 = i[Symbol.toPrimitive];
      if (t2) {
        const i2 = t2(_);
        if ("object" != typeof i2)
          return i2;
        throw new TypeError("Cannot convert object to primitive value");
      }
    }
    const t = i.valueOf;
    if (t) {
      const _2 = t.call(i);
      if ("object" != typeof _2)
        return _2;
    }
    const e = i.toString;
    if (e) {
      const _2 = e.call(i);
      if ("object" != typeof _2)
        return _2;
    }
    throw new TypeError("Cannot convert object to primitive value");
  }
  static __toNumeric(i) {
    return JSBI.__isBigInt(i) ? i : +i;
  }
  static __isBigInt(i) {
    return "object" == typeof i && null !== i && i.constructor === JSBI;
  }
  static __truncateToNBits(i, _) {
    const t = 0 | (i + 29) / 30, e = new JSBI(t, _.sign), n = t - 1;
    for (let t2 = 0; t2 < n; t2++)
      e.__setDigit(t2, _.__digit(t2));
    let g = _.__digit(n);
    if (0 != i % 30) {
      const _2 = 32 - i % 30;
      g = g << _2 >>> _2;
    }
    return e.__setDigit(n, g), e.__trim();
  }
  static __truncateAndSubFromPowerOfTwo(_, t, e) {
    var n = Math.min;
    const g = 0 | (_ + 29) / 30, o = new JSBI(g, e);
    let s = 0;
    const l = g - 1;
    let a = 0;
    for (const i = n(l, t.length); s < i; s++) {
      const i2 = 0 - t.__digit(s) - a;
      a = 1 & i2 >>> 30, o.__setDigit(s, 1073741823 & i2);
    }
    for (; s < l; s++)
      o.__setDigit(s, 0 | 1073741823 & -a);
    let u = l < t.length ? t.__digit(l) : 0;
    const d = _ % 30;
    let h;
    if (0 == d)
      h = 0 - u - a, h &= 1073741823;
    else {
      const i = 32 - d;
      u = u << i >>> i;
      const _2 = 1 << 32 - i;
      h = _2 - u - a, h &= _2 - 1;
    }
    return o.__setDigit(l, h), o.__trim();
  }
  __digit(_) {
    return this[_];
  }
  __unsignedDigit(_) {
    return this[_] >>> 0;
  }
  __setDigit(_, i) {
    this[_] = 0 | i;
  }
  __setDigitGrow(_, i) {
    this[_] = 0 | i;
  }
  __halfDigitLength() {
    const i = this.length;
    return 32767 >= this.__unsignedDigit(i - 1) ? 2 * i - 1 : 2 * i;
  }
  __halfDigit(_) {
    return 32767 & this[_ >>> 1] >>> 15 * (1 & _);
  }
  __setHalfDigit(_, i) {
    const t = _ >>> 1, e = this.__digit(t), n = 1 & _ ? 32767 & e | i << 15 : 1073709056 & e | 32767 & i;
    this.__setDigit(t, n);
  }
  static __digitPow(i, _) {
    let t = 1;
    for (; 0 < _; )
      1 & _ && (t *= i), _ >>>= 1, i *= i;
    return t;
  }
  static __isOneDigitInt(i) {
    return (1073741823 & i) === i;
  }
};
JSBI.__kMaxLength = 33554432, JSBI.__kMaxLengthBits = JSBI.__kMaxLength << 5, JSBI.__kMaxBitsPerChar = [0, 0, 32, 51, 64, 75, 83, 90, 96, 102, 107, 111, 115, 119, 122, 126, 128, 131, 134, 136, 139, 141, 143, 145, 147, 149, 151, 153, 154, 156, 158, 159, 160, 162, 163, 165, 166], JSBI.__kBitsPerCharTableShift = 5, JSBI.__kBitsPerCharTableMultiplier = 1 << JSBI.__kBitsPerCharTableShift, JSBI.__kConversionChars = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"], JSBI.__kBitConversionBuffer = new ArrayBuffer(8), JSBI.__kBitConversionDouble = new Float64Array(JSBI.__kBitConversionBuffer), JSBI.__kBitConversionInts = new Int32Array(JSBI.__kBitConversionBuffer), JSBI.__clz30 = Math.clz32 ? function(i) {
  return Math.clz32(i) - 2;
} : function(i) {
  return 0 === i ? 30 : 0 | 29 - (0 | Math.log(i >>> 0) / Math.LN2);
}, JSBI.__imul = Math.imul || function(i, _) {
  return 0 | i * _;
};
var jsbi_default = JSBI;

// node_modules/use-wallet/dist/esm/index.js
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function() {
    var self = this, args = arguments;
    return new Promise(function(resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(void 0);
    });
  };
}
function _extends2() {
  _extends2 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends2.apply(this, arguments);
}
function _inheritsLoose2(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf2(subClass, superClass);
}
function _getPrototypeOf2(o) {
  _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf2(o);
}
function _setPrototypeOf2(o, p) {
  _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf2(o, p);
}
function _isNativeReflectConstruct2() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _construct2(Parent, args, Class) {
  if (_isNativeReflectConstruct2()) {
    _construct2 = Reflect.construct;
  } else {
    _construct2 = function _construct3(Parent2, args2, Class2) {
      var a = [null];
      a.push.apply(a, args2);
      var Constructor = Function.bind.apply(Parent2, a);
      var instance = new Constructor();
      if (Class2)
        _setPrototypeOf2(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct2.apply(null, arguments);
}
function _isNativeFunction2(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
function _wrapNativeSuper2(Class) {
  var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
  _wrapNativeSuper2 = function _wrapNativeSuper3(Class2) {
    if (Class2 === null || !_isNativeFunction2(Class2))
      return Class2;
    if (typeof Class2 !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class2))
        return _cache.get(Class2);
      _cache.set(Class2, Wrapper);
    }
    function Wrapper() {
      return _construct2(Class2, arguments, _getPrototypeOf2(this).constructor);
    }
    Wrapper.prototype = Object.create(Class2.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf2(Wrapper, Class2);
  };
  return _wrapNativeSuper2(Class);
}
function createCommonjsModule(fn, module) {
  return module = { exports: {} }, fn(module, module.exports), module.exports;
}
var runtime_1 = createCommonjsModule(function(module) {
  var runtime = function(exports) {
    var Op = Object.prototype;
    var hasOwn = Op.hasOwnProperty;
    var undefined$1;
    var $Symbol = typeof Symbol === "function" ? Symbol : {};
    var iteratorSymbol = $Symbol.iterator || "@@iterator";
    var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
    var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
    function define(obj, key, value) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
      return obj[key];
    }
    try {
      define({}, "");
    } catch (err) {
      define = function(obj, key, value) {
        return obj[key] = value;
      };
    }
    function wrap(innerFn, outerFn, self, tryLocsList) {
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
      var generator = Object.create(protoGenerator.prototype);
      var context = new Context(tryLocsList || []);
      generator._invoke = makeInvokeMethod(innerFn, self, context);
      return generator;
    }
    exports.wrap = wrap;
    function tryCatch(fn, obj, arg) {
      try {
        return { type: "normal", arg: fn.call(obj, arg) };
      } catch (err) {
        return { type: "throw", arg: err };
      }
    }
    var GenStateSuspendedStart = "suspendedStart";
    var GenStateSuspendedYield = "suspendedYield";
    var GenStateExecuting = "executing";
    var GenStateCompleted = "completed";
    var ContinueSentinel = {};
    function Generator() {
    }
    function GeneratorFunction() {
    }
    function GeneratorFunctionPrototype() {
    }
    var IteratorPrototype = {};
    IteratorPrototype[iteratorSymbol] = function() {
      return this;
    };
    var getProto = Object.getPrototypeOf;
    var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
    if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
      IteratorPrototype = NativeIteratorPrototype;
    }
    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
    GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
    GeneratorFunctionPrototype.constructor = GeneratorFunction;
    GeneratorFunction.displayName = define(
      GeneratorFunctionPrototype,
      toStringTagSymbol,
      "GeneratorFunction"
    );
    function defineIteratorMethods(prototype) {
      ["next", "throw", "return"].forEach(function(method) {
        define(prototype, method, function(arg) {
          return this._invoke(method, arg);
        });
      });
    }
    exports.isGeneratorFunction = function(genFun) {
      var ctor = typeof genFun === "function" && genFun.constructor;
      return ctor ? ctor === GeneratorFunction || (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
    };
    exports.mark = function(genFun) {
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
      } else {
        genFun.__proto__ = GeneratorFunctionPrototype;
        define(genFun, toStringTagSymbol, "GeneratorFunction");
      }
      genFun.prototype = Object.create(Gp);
      return genFun;
    };
    exports.awrap = function(arg) {
      return { __await: arg };
    };
    function AsyncIterator(generator, PromiseImpl) {
      function invoke(method, arg, resolve, reject) {
        var record = tryCatch(generator[method], generator, arg);
        if (record.type === "throw") {
          reject(record.arg);
        } else {
          var result = record.arg;
          var value = result.value;
          if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
            return PromiseImpl.resolve(value.__await).then(function(value2) {
              invoke("next", value2, resolve, reject);
            }, function(err) {
              invoke("throw", err, resolve, reject);
            });
          }
          return PromiseImpl.resolve(value).then(function(unwrapped) {
            result.value = unwrapped;
            resolve(result);
          }, function(error) {
            return invoke("throw", error, resolve, reject);
          });
        }
      }
      var previousPromise;
      function enqueue(method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function(resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }
        return previousPromise = previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
      }
      this._invoke = enqueue;
    }
    defineIteratorMethods(AsyncIterator.prototype);
    AsyncIterator.prototype[asyncIteratorSymbol] = function() {
      return this;
    };
    exports.AsyncIterator = AsyncIterator;
    exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
      if (PromiseImpl === void 0)
        PromiseImpl = Promise;
      var iter = new AsyncIterator(
        wrap(innerFn, outerFn, self, tryLocsList),
        PromiseImpl
      );
      return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
        return result.done ? result.value : iter.next();
      });
    };
    function makeInvokeMethod(innerFn, self, context) {
      var state = GenStateSuspendedStart;
      return function invoke(method, arg) {
        if (state === GenStateExecuting) {
          throw new Error("Generator is already running");
        }
        if (state === GenStateCompleted) {
          if (method === "throw") {
            throw arg;
          }
          return doneResult();
        }
        context.method = method;
        context.arg = arg;
        while (true) {
          var delegate = context.delegate;
          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);
            if (delegateResult) {
              if (delegateResult === ContinueSentinel)
                continue;
              return delegateResult;
            }
          }
          if (context.method === "next") {
            context.sent = context._sent = context.arg;
          } else if (context.method === "throw") {
            if (state === GenStateSuspendedStart) {
              state = GenStateCompleted;
              throw context.arg;
            }
            context.dispatchException(context.arg);
          } else if (context.method === "return") {
            context.abrupt("return", context.arg);
          }
          state = GenStateExecuting;
          var record = tryCatch(innerFn, self, context);
          if (record.type === "normal") {
            state = context.done ? GenStateCompleted : GenStateSuspendedYield;
            if (record.arg === ContinueSentinel) {
              continue;
            }
            return {
              value: record.arg,
              done: context.done
            };
          } else if (record.type === "throw") {
            state = GenStateCompleted;
            context.method = "throw";
            context.arg = record.arg;
          }
        }
      };
    }
    function maybeInvokeDelegate(delegate, context) {
      var method = delegate.iterator[context.method];
      if (method === undefined$1) {
        context.delegate = null;
        if (context.method === "throw") {
          if (delegate.iterator["return"]) {
            context.method = "return";
            context.arg = undefined$1;
            maybeInvokeDelegate(delegate, context);
            if (context.method === "throw") {
              return ContinueSentinel;
            }
          }
          context.method = "throw";
          context.arg = new TypeError(
            "The iterator does not provide a 'throw' method"
          );
        }
        return ContinueSentinel;
      }
      var record = tryCatch(method, delegate.iterator, context.arg);
      if (record.type === "throw") {
        context.method = "throw";
        context.arg = record.arg;
        context.delegate = null;
        return ContinueSentinel;
      }
      var info = record.arg;
      if (!info) {
        context.method = "throw";
        context.arg = new TypeError("iterator result is not an object");
        context.delegate = null;
        return ContinueSentinel;
      }
      if (info.done) {
        context[delegate.resultName] = info.value;
        context.next = delegate.nextLoc;
        if (context.method !== "return") {
          context.method = "next";
          context.arg = undefined$1;
        }
      } else {
        return info;
      }
      context.delegate = null;
      return ContinueSentinel;
    }
    defineIteratorMethods(Gp);
    define(Gp, toStringTagSymbol, "Generator");
    Gp[iteratorSymbol] = function() {
      return this;
    };
    Gp.toString = function() {
      return "[object Generator]";
    };
    function pushTryEntry(locs) {
      var entry = { tryLoc: locs[0] };
      if (1 in locs) {
        entry.catchLoc = locs[1];
      }
      if (2 in locs) {
        entry.finallyLoc = locs[2];
        entry.afterLoc = locs[3];
      }
      this.tryEntries.push(entry);
    }
    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal";
      delete record.arg;
      entry.completion = record;
    }
    function Context(tryLocsList) {
      this.tryEntries = [{ tryLoc: "root" }];
      tryLocsList.forEach(pushTryEntry, this);
      this.reset(true);
    }
    exports.keys = function(object2) {
      var keys = [];
      for (var key in object2) {
        keys.push(key);
      }
      keys.reverse();
      return function next() {
        while (keys.length) {
          var key2 = keys.pop();
          if (key2 in object2) {
            next.value = key2;
            next.done = false;
            return next;
          }
        }
        next.done = true;
        return next;
      };
    };
    function values(iterable) {
      if (iterable) {
        var iteratorMethod = iterable[iteratorSymbol];
        if (iteratorMethod) {
          return iteratorMethod.call(iterable);
        }
        if (typeof iterable.next === "function") {
          return iterable;
        }
        if (!isNaN(iterable.length)) {
          var i = -1, next = function next2() {
            while (++i < iterable.length) {
              if (hasOwn.call(iterable, i)) {
                next2.value = iterable[i];
                next2.done = false;
                return next2;
              }
            }
            next2.value = undefined$1;
            next2.done = true;
            return next2;
          };
          return next.next = next;
        }
      }
      return { next: doneResult };
    }
    exports.values = values;
    function doneResult() {
      return { value: undefined$1, done: true };
    }
    Context.prototype = {
      constructor: Context,
      reset: function(skipTempReset) {
        this.prev = 0;
        this.next = 0;
        this.sent = this._sent = undefined$1;
        this.done = false;
        this.delegate = null;
        this.method = "next";
        this.arg = undefined$1;
        this.tryEntries.forEach(resetTryEntry);
        if (!skipTempReset) {
          for (var name in this) {
            if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
              this[name] = undefined$1;
            }
          }
        }
      },
      stop: function() {
        this.done = true;
        var rootEntry = this.tryEntries[0];
        var rootRecord = rootEntry.completion;
        if (rootRecord.type === "throw") {
          throw rootRecord.arg;
        }
        return this.rval;
      },
      dispatchException: function(exception) {
        if (this.done) {
          throw exception;
        }
        var context = this;
        function handle(loc, caught) {
          record.type = "throw";
          record.arg = exception;
          context.next = loc;
          if (caught) {
            context.method = "next";
            context.arg = undefined$1;
          }
          return !!caught;
        }
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          var record = entry.completion;
          if (entry.tryLoc === "root") {
            return handle("end");
          }
          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn.call(entry, "catchLoc");
            var hasFinally = hasOwn.call(entry, "finallyLoc");
            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              } else if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
            } else if (hasCatch) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              }
            } else if (hasFinally) {
              if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
            } else {
              throw new Error("try statement without catch or finally");
            }
          }
        }
      },
      abrupt: function(type, arg) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }
        if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
          finallyEntry = null;
        }
        var record = finallyEntry ? finallyEntry.completion : {};
        record.type = type;
        record.arg = arg;
        if (finallyEntry) {
          this.method = "next";
          this.next = finallyEntry.finallyLoc;
          return ContinueSentinel;
        }
        return this.complete(record);
      },
      complete: function(record, afterLoc) {
        if (record.type === "throw") {
          throw record.arg;
        }
        if (record.type === "break" || record.type === "continue") {
          this.next = record.arg;
        } else if (record.type === "return") {
          this.rval = this.arg = record.arg;
          this.method = "return";
          this.next = "end";
        } else if (record.type === "normal" && afterLoc) {
          this.next = afterLoc;
        }
        return ContinueSentinel;
      },
      finish: function(finallyLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.finallyLoc === finallyLoc) {
            this.complete(entry.completion, entry.afterLoc);
            resetTryEntry(entry);
            return ContinueSentinel;
          }
        }
      },
      "catch": function(tryLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;
            if (record.type === "throw") {
              var thrown = record.arg;
              resetTryEntry(entry);
            }
            return thrown;
          }
        }
        throw new Error("illegal catch attempt");
      },
      delegateYield: function(iterable, resultName, nextLoc) {
        this.delegate = {
          iterator: values(iterable),
          resultName,
          nextLoc
        };
        if (this.method === "next") {
          this.arg = undefined$1;
        }
        return ContinueSentinel;
      }
    };
    return exports;
  }(
    module.exports
  );
  try {
    regeneratorRuntime = runtime;
  } catch (accidentalStrictMode) {
    Function("r", "regeneratorRuntime = r")(runtime);
  }
});
var ChainUnsupportedError = function(_Error) {
  _inheritsLoose2(ChainUnsupportedError2, _Error);
  function ChainUnsupportedError2(message) {
    var _this;
    for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      params[_key - 1] = arguments[_key];
    }
    _this = _Error.call.apply(_Error, [this].concat(params)) || this;
    _this.name = "ChainUnsupportedError";
    _this.message = message;
    return _this;
  }
  return ChainUnsupportedError2;
}(_wrapNativeSuper2(Error));
var ConnectorUnsupportedError = function(_Error2) {
  _inheritsLoose2(ConnectorUnsupportedError2, _Error2);
  function ConnectorUnsupportedError2(connectorId) {
    var _this2;
    for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      params[_key2 - 1] = arguments[_key2];
    }
    _this2 = _Error2.call.apply(_Error2, [this].concat(params)) || this;
    _this2.name = "ConnectorUnsupportedError";
    _this2.message = "Unsupported connector: " + connectorId + ".";
    return _this2;
  }
  return ConnectorUnsupportedError2;
}(_wrapNativeSuper2(Error));
var ConnectionRejectedError = function(_Error3) {
  _inheritsLoose2(ConnectionRejectedError2, _Error3);
  function ConnectionRejectedError2() {
    var _this3;
    for (var _len3 = arguments.length, params = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      params[_key3] = arguments[_key3];
    }
    _this3 = _Error3.call.apply(_Error3, [this].concat(params)) || this;
    _this3.name = "ConnectionRejectedError";
    _this3.message = "The activation has been rejected by the provider.";
    return _this3;
  }
  return ConnectionRejectedError2;
}(_wrapNativeSuper2(Error));
var ConnectorConfigError = function(_Error4) {
  _inheritsLoose2(ConnectorConfigError2, _Error4);
  function ConnectorConfigError2() {
    var _this4;
    for (var _len4 = arguments.length, params = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      params[_key4] = arguments[_key4];
    }
    _this4 = _Error4.call.apply(_Error4, [this].concat(params)) || this;
    _this4.name = "ConnectorConfigError";
    return _this4;
  }
  return ConnectorConfigError2;
}(_wrapNativeSuper2(Error));
function init() {
  return _init.apply(this, arguments);
}
function _init() {
  _init = _asyncToGenerator(runtime_1.mark(function _callee() {
    var _yield$import, FortmaticConnector;
    return runtime_1.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return import("./fortmatic-connector.esm-TJYPVHPD.js");
          case 2:
            _yield$import = _context.sent;
            FortmaticConnector = _yield$import.FortmaticConnector;
            return _context.abrupt("return", {
              web3ReactConnector: function web3ReactConnector(_ref) {
                var chainId = _ref.chainId, apiKey = _ref.apiKey;
                if (!apiKey) {
                  throw new ConnectorConfigError("The Fortmatic connector requires apiKey to be set.");
                }
                return new FortmaticConnector({
                  apiKey,
                  chainId
                });
              }
            });
          case 5:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _init.apply(this, arguments);
}
function init$1() {
  return _init$1.apply(this, arguments);
}
function _init$1() {
  _init$1 = _asyncToGenerator(runtime_1.mark(function _callee() {
    var _yield$import, FrameConnector, UserRejectedRequestError;
    return runtime_1.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return import("./frame-connector.esm-DXZ73KFB.js");
          case 2:
            _yield$import = _context.sent;
            FrameConnector = _yield$import.FrameConnector;
            UserRejectedRequestError = _yield$import.UserRejectedRequestError;
            return _context.abrupt("return", {
              web3ReactConnector: function web3ReactConnector(_ref) {
                var chainId = _ref.chainId;
                return new FrameConnector({
                  supportedChainIds: [chainId]
                });
              },
              handleActivationError: function handleActivationError(err) {
                if (err instanceof UserRejectedRequestError) {
                  return new ConnectionRejectedError();
                }
                if (err.message.startsWith("JSON.parse")) {
                  return new Error("There seems to be an issue when trying to connect to Frame.");
                }
                return null;
              }
            });
          case 6:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _init$1.apply(this, arguments);
}
function init$2() {
  return _init$2.apply(this, arguments);
}
function _init$2() {
  _init$2 = _asyncToGenerator(runtime_1.mark(function _callee() {
    var _yield$import, InjectedConnector, UserRejectedRequestError;
    return runtime_1.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return import("./injected-connector.esm-WX6OXFO2.js");
          case 2:
            _yield$import = _context.sent;
            InjectedConnector = _yield$import.InjectedConnector;
            UserRejectedRequestError = _yield$import.UserRejectedRequestError;
            return _context.abrupt("return", {
              web3ReactConnector: function web3ReactConnector(_ref) {
                var chainId = _ref.chainId;
                return new InjectedConnector({
                  supportedChainIds: chainId
                });
              },
              handleActivationError: function handleActivationError(err) {
                return err instanceof UserRejectedRequestError ? new ConnectionRejectedError() : null;
              }
            });
          case 6:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _init$2.apply(this, arguments);
}
function init$3() {
  return _init$3.apply(this, arguments);
}
function _init$3() {
  _init$3 = _asyncToGenerator(runtime_1.mark(function _callee() {
    var _yield$import, PortisConnector;
    return runtime_1.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return import("./portis-connector.esm-I5VGTNM7.js");
          case 2:
            _yield$import = _context.sent;
            PortisConnector = _yield$import.PortisConnector;
            return _context.abrupt("return", {
              web3ReactConnector: function web3ReactConnector(_ref) {
                var chainId = _ref.chainId, dAppId = _ref.dAppId;
                if (!dAppId) {
                  throw new ConnectorConfigError("The Portis connector requires dAppId to be set.");
                }
                return new PortisConnector({
                  dAppId,
                  networks: chainId
                });
              }
            });
          case 5:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _init$3.apply(this, arguments);
}
function init$4() {
  return _init$4.apply(this, arguments);
}
function _init$4() {
  _init$4 = _asyncToGenerator(runtime_1.mark(function _callee() {
    var _yield$import, ProvidedConnector, UserRejectedRequestError;
    return runtime_1.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return import("./provided-connector.esm-7NHTHYOJ.js");
          case 2:
            _yield$import = _context.sent;
            ProvidedConnector = _yield$import.ProvidedConnector;
            UserRejectedRequestError = _yield$import.UserRejectedRequestError;
            return _context.abrupt("return", {
              web3ReactConnector: function web3ReactConnector(_ref) {
                var chainId = _ref.chainId, provider = _ref.provider;
                return new ProvidedConnector({
                  provider,
                  supportedChainIds: chainId
                });
              },
              handleActivationError: function handleActivationError(err) {
                return err instanceof UserRejectedRequestError ? new ConnectionRejectedError() : null;
              }
            });
          case 6:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _init$4.apply(this, arguments);
}
function init$5() {
  return _init$5.apply(this, arguments);
}
function _init$5() {
  _init$5 = _asyncToGenerator(runtime_1.mark(function _callee() {
    var _yield$import, TorusConnector;
    return runtime_1.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return import("./torus-connector.esm-6ODK5E6P.js");
          case 2:
            _yield$import = _context.sent;
            TorusConnector = _yield$import.TorusConnector;
            return _context.abrupt("return", {
              web3ReactConnector: function web3ReactConnector(_ref) {
                var chainId = _ref.chainId, initOptions = _ref.initOptions, constructorOptions = _ref.constructorOptions;
                return new TorusConnector({
                  chainId,
                  constructorOptions,
                  initOptions
                });
              }
            });
          case 5:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _init$5.apply(this, arguments);
}
function init$6() {
  return _init$6.apply(this, arguments);
}
function _init$6() {
  _init$6 = _asyncToGenerator(runtime_1.mark(function _callee() {
    var _yield$import, UserRejectedRequestError, WalletConnectConnector;
    return runtime_1.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return import("./walletconnect-connector.esm-HDT2TJ7V.js");
          case 2:
            _yield$import = _context.sent;
            UserRejectedRequestError = _yield$import.UserRejectedRequestError;
            WalletConnectConnector = _yield$import.WalletConnectConnector;
            return _context.abrupt("return", {
              web3ReactConnector: function web3ReactConnector(_ref) {
                var _rpc;
                var chainId = _ref.chainId, rpcUrl = _ref.rpcUrl, bridge = _ref.bridge, pollingInterval = _ref.pollingInterval;
                if (!rpcUrl) {
                  throw new ConnectorConfigError("The WalletConnect connector requires rpcUrl to be set.");
                }
                if (!/^https?:\/\//.test(rpcUrl)) {
                  throw new ConnectorConfigError("The WalletConnect connector requires rpcUrl to be an HTTP URL.");
                }
                return new WalletConnectConnector({
                  bridge,
                  pollingInterval,
                  qrcode: true,
                  rpc: (_rpc = {}, _rpc[chainId] = rpcUrl, _rpc)
                });
              },
              handleActivationError: function handleActivationError(err) {
                return err instanceof UserRejectedRequestError ? new ConnectionRejectedError() : null;
              }
            });
          case 6:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _init$6.apply(this, arguments);
}
function init$7() {
  return _init$7.apply(this, arguments);
}
function _init$7() {
  _init$7 = _asyncToGenerator(runtime_1.mark(function _callee() {
    var _yield$import, WalletLinkConnector;
    return runtime_1.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return import("./walletlink-connector.esm-PXJ4X3MT.js");
          case 2:
            _yield$import = _context.sent;
            WalletLinkConnector = _yield$import.WalletLinkConnector;
            return _context.abrupt("return", {
              web3ReactConnector: function web3ReactConnector(_ref) {
                var chainId = _ref.chainId, url = _ref.url, appName = _ref.appName, appLogoUrl = _ref.appLogoUrl;
                if (chainId !== 1) {
                  throw new ConnectorConfigError("The WalletLink connector requires chainId to be 1.");
                }
                if (!/^https?:\/\//.test(url)) {
                  throw new ConnectorConfigError("The WalletLink connector requires url to be an HTTP URL.");
                }
                return new WalletLinkConnector({
                  url,
                  appName,
                  appLogoUrl
                });
              }
            });
          case 5:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _init$7.apply(this, arguments);
}
var LEDGER_LIVE_PATH = "m/44'/60'/0'/0";
var POLLING_INTERVAL = 12e3;
function init$8() {
  return _init$8.apply(this, arguments);
}
function _init$8() {
  _init$8 = _asyncToGenerator(runtime_1.mark(function _callee() {
    var _yield$import, LedgerConnector;
    return runtime_1.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return import("./ledger-connector.esm-MPVNPDUG.js");
          case 2:
            _yield$import = _context.sent;
            LedgerConnector = _yield$import.LedgerConnector;
            return _context.abrupt("return", {
              web3ReactConnector: function web3ReactConnector(_ref) {
                var chainId = _ref.chainId, url = _ref.url;
                if (!url) {
                  throw new ConnectorConfigError("The Ledger connector requires url to be set.");
                }
                return new LedgerConnector({
                  url,
                  chainId,
                  pollingInterval: POLLING_INTERVAL,
                  baseDerivationPath: LEDGER_LIVE_PATH
                });
              }
            });
          case 5:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _init$8.apply(this, arguments);
}
function getConnectors(initsOrConfigs) {
  if (initsOrConfigs === void 0) {
    initsOrConfigs = {};
  }
  var connectors = {
    fortmatic: [init, null],
    frame: [init$1, null],
    injected: [init$2, null],
    portis: [init$3, null],
    provided: [init$4, null],
    torus: [init$5, null],
    walletconnect: [init$6, null],
    walletlink: [init$7, null],
    ledger: [init$8, null]
  };
  for (var _i = 0, _Object$entries = Object.entries(initsOrConfigs); _i < _Object$entries.length; _i++) {
    var _Object$entries$_i = _Object$entries[_i], id = _Object$entries$_i[0], initOrConfig = _Object$entries$_i[1];
    if (typeof initOrConfig === "function") {
      connectors[id] = [initOrConfig, null];
      continue;
    }
    if (connectors[id]) {
      connectors[id][1] = initOrConfig;
    }
  }
  return connectors;
}
function isUnwrappedRpcResult(response) {
  return typeof response === "object" && response !== null && "jsonrpc" in response;
}
function rpcResult(response) {
  if (isUnwrappedRpcResult(response)) {
    if (response.error) {
      throw new Error(response.error);
    }
    return response.result || null;
  }
  return response || null;
}
function ethereumRequest(_x, _x2, _x3) {
  return _ethereumRequest.apply(this, arguments);
}
function _ethereumRequest() {
  _ethereumRequest = _asyncToGenerator(runtime_1.mark(function _callee2(ethereum, method, params) {
    return runtime_1.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (!ethereum.request) {
              _context2.next = 2;
              break;
            }
            return _context2.abrupt("return", ethereum.request({
              method,
              params
            }).then(rpcResult));
          case 2:
            if (!(ethereum.sendAsync && ethereum.selectedAddress)) {
              _context2.next = 4;
              break;
            }
            return _context2.abrupt("return", new Promise(function(resolve, reject) {
              ethereum.sendAsync({
                method,
                params,
                from: ethereum.selectedAddress,
                jsonrpc: "2.0",
                id: 0
              }, function(err, result) {
                if (err) {
                  reject(err);
                } else {
                  resolve(result);
                }
              });
            }).then(rpcResult));
          case 4:
            if (!ethereum.send) {
              _context2.next = 6;
              break;
            }
            return _context2.abrupt("return", ethereum.send(method, params).then(rpcResult));
          case 6:
            throw new Error("The Ethereum provider doesn\u2019t seem to provide a request method.");
          case 7:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _ethereumRequest.apply(this, arguments);
}
function getAccountIsContract(_x4, _x5) {
  return _getAccountIsContract.apply(this, arguments);
}
function _getAccountIsContract() {
  _getAccountIsContract = _asyncToGenerator(runtime_1.mark(function _callee3(ethereum, account) {
    var code;
    return runtime_1.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.prev = 0;
            _context3.next = 3;
            return ethereumRequest(ethereum, "eth_getCode", [account]);
          case 3:
            code = _context3.sent;
            return _context3.abrupt("return", code !== "0x");
          case 7:
            _context3.prev = 7;
            _context3.t0 = _context3["catch"](0);
            return _context3.abrupt("return", false);
          case 10:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, null, [[0, 7]]);
  }));
  return _getAccountIsContract.apply(this, arguments);
}
function getAccountBalance(_x6, _x7) {
  return _getAccountBalance.apply(this, arguments);
}
function _getAccountBalance() {
  _getAccountBalance = _asyncToGenerator(runtime_1.mark(function _callee4(ethereum, account) {
    return runtime_1.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            return _context4.abrupt("return", ethereumRequest(ethereum, "eth_getBalance", [account, "latest"]));
          case 1:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));
  return _getAccountBalance.apply(this, arguments);
}
function getBlockNumber(_x8) {
  return _getBlockNumber.apply(this, arguments);
}
function _getBlockNumber() {
  _getBlockNumber = _asyncToGenerator(runtime_1.mark(function _callee5(ethereum) {
    return runtime_1.wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            return _context5.abrupt("return", ethereumRequest(ethereum, "eth_blockNumber", []));
          case 1:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5);
  }));
  return _getBlockNumber.apply(this, arguments);
}
function pollEvery(fn, delay) {
  var timer;
  var stop = false;
  var poll = function() {
    var _ref = _asyncToGenerator(runtime_1.mark(function _callee(request, onResult) {
      var result;
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return request();
            case 2:
              result = _context.sent;
              if (!stop) {
                onResult(result);
                timer = setTimeout(poll.bind(null, request, onResult), delay);
              }
            case 4:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return function poll2(_x9, _x10) {
      return _ref.apply(this, arguments);
    };
  }();
  return function() {
    var _fn = fn.apply(void 0, arguments), request = _fn.request, onResult = _fn.onResult;
    stop = false;
    poll(request, onResult);
    return function() {
      stop = true;
      clearTimeout(timer);
    };
  };
}
var ETH = {
  name: "Ether",
  symbol: "ETH",
  decimals: 18
};
var MATIC = {
  name: "Matic Token",
  symbol: "MATIC",
  decimals: 18
};
var KNOWN_CHAINS = /* @__PURE__ */ new Map([[1, {
  id: 1,
  nativeCurrency: ETH,
  type: "main",
  fullName: "Ethereum Mainnet",
  shortName: "Mainnet",
  explorerUrl: "https://etherscan.io"
}], [2, {
  id: 2,
  type: "expanse"
}], [3, {
  id: 3,
  nativeCurrency: ETH,
  type: "ropsten",
  fullName: "Ethereum Ropsten",
  shortName: "Ropsten",
  explorerUrl: "https://ropsten.etherscan.io"
}], [4, {
  id: 4,
  nativeCurrency: ETH,
  type: "rinkeby",
  fullName: "Ethereum Rinkeby",
  shortName: "Rinkeby",
  explorerUrl: "https://rinkeby.etherscan.io"
}], [5, {
  id: 5,
  nativeCurrency: ETH,
  type: "goerli",
  fullName: "Ethereum Goerli",
  shortName: "Goerli",
  explorerUrl: "https://goerli.etherscan.io"
}], [8, {
  id: 8,
  type: "ubiq"
}], [42, {
  id: 42,
  nativeCurrency: ETH,
  type: "kovan",
  fullName: "Ethereum Kovan",
  shortName: "Kovan",
  explorerUrl: "https://kovan.etherscan.io"
}], [100, {
  id: 100,
  type: "xdai"
}], [137, {
  id: 137,
  nativeCurrency: MATIC,
  type: "matic",
  fullName: "Polygon Mainnet",
  shortName: "Matic",
  explorerUrl: "https://polygonscan.com"
}], [80001, {
  id: 80001,
  nativeCurrency: MATIC,
  type: "mumbai",
  fullName: "Polygon Testnet",
  shortName: "Mumbai",
  explorerUrl: "https://mumbai.polygonscan.com"
}], [1337, {
  id: 1337,
  type: "local"
}], [5777, {
  id: 5777,
  type: "ganache"
}]]);
function isElectron() {
  return typeof navigator === "object" && typeof navigator.userAgent === "string" && navigator.userAgent.indexOf("Electron") >= 0;
}
var BASE_URL = "https://storageapi.fleek.co/aragonone-team-bucket/wallet-icons";
var PROVIDERS = new Map([{
  id: "frame",
  name: "Frame",
  type: "Desktop",
  image: BASE_URL + "/Frame.png",
  strings: {
    "your Ethereum wallet": "Frame"
  }
}, {
  id: "metamask",
  name: "Metamask",
  type: "Desktop",
  image: BASE_URL + "/Metamask.png",
  strings: {
    "your Ethereum wallet": "Metamask"
  }
}, {
  id: "status",
  name: "Status",
  type: "Mobile",
  image: BASE_URL + "/Status.png",
  strings: {
    "your Ethereum wallet": "Status"
  }
}, {
  id: "cipher",
  name: "Cipher",
  type: "Mobile",
  image: BASE_URL + "/Cipher.png",
  strings: {
    "your Ethereum wallet": "Cipher"
  }
}, {
  id: "fortmatic",
  name: "Fortmatic",
  type: "Any",
  image: BASE_URL + "/Fortmatic.svg",
  strings: {
    "your Ethereum wallet": "Fortmatic"
  }
}, {
  id: "portis",
  name: "Portis",
  type: "Any",
  image: BASE_URL + "/Portis.svg",
  strings: {
    "your Ethereum wallet": "Portis"
  }
}, {
  id: "unknown",
  name: "Unknown",
  type: "Desktop",
  image: BASE_URL + "/wallet.svg",
  strings: {
    "your Ethereum wallet": "your wallet"
  }
}].map(function(provider) {
  return [provider.id, provider];
}));
function getProvider(providerId) {
  return PROVIDERS.get(providerId);
}
function getProviderString(string, providerId) {
  if (providerId === void 0) {
    providerId = "unknown";
  }
  var provider = getProvider(providerId);
  return provider && provider.strings[string] || string;
}
function identifyProvider(provider) {
  if (provider && isElectron()) {
    return "frame";
  }
  if (provider && provider.isMetaMask) {
    return "metamask";
  }
  return "unknown";
}
function getProviderFromUseWalletId(id) {
  if (id === "injected" || id === "provided") {
    return getProvider(identifyProvider(window.ethereum)) || getProvider("unknown");
  }
  return getProvider(id) || getProvider("unknown");
}
var NO_BALANCE = "-1";
var UseWalletContext = (0, import_react2.createContext)(null);
function useWallet() {
  var walletContext = (0, import_react2.useContext)(UseWalletContext);
  if (walletContext === null) {
    throw new Error("useWallet() can only be used inside of <UseWalletProvider />, please declare it at a higher level.");
  }
  var getBlockNumber2 = useGetBlockNumber();
  var wallet = walletContext.wallet;
  return (0, import_react2.useMemo)(function() {
    return _extends2({}, wallet, {
      getBlockNumber: getBlockNumber2
    });
  }, [getBlockNumber2, wallet]);
}
function useGetBlockNumber() {
  var walletContext = (0, import_react2.useContext)(UseWalletContext);
  var _useState = (0, import_react2.useState)(null), blockNumber = _useState[0], setBlockNumber = _useState[1];
  var requestedBlockNumber = (0, import_react2.useRef)(false);
  var getBlockNumber2 = (0, import_react2.useCallback)(function() {
    if (walletContext === null) {
      return null;
    }
    requestedBlockNumber.current = true;
    walletContext.addBlockNumberListener(setBlockNumber);
    return blockNumber;
  }, [walletContext, blockNumber]);
  (0, import_react2.useEffect)(function() {
    if (!requestedBlockNumber.current || walletContext === null) {
      return;
    }
    walletContext.addBlockNumberListener(setBlockNumber);
    return function() {
      walletContext.removeBlockNumberListener(setBlockNumber);
    };
  }, [requestedBlockNumber, walletContext]);
  return getBlockNumber2;
}
function useWalletBalance(_ref) {
  var account = _ref.account, ethereum = _ref.ethereum, pollBalanceInterval = _ref.pollBalanceInterval;
  var _useState2 = (0, import_react2.useState)(NO_BALANCE), balance = _useState2[0], setBalance = _useState2[1];
  (0, import_react2.useEffect)(function() {
    if (!account || !ethereum) {
      return;
    }
    var cancel = false;
    var pollBalance = pollEvery(function(account2, ethereum2, onUpdate) {
      var lastBalance = NO_BALANCE;
      return {
        request: function request() {
          return _asyncToGenerator(runtime_1.mark(function _callee() {
            return runtime_1.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    return _context.abrupt("return", getAccountBalance(ethereum2, account2).then(function(value) {
                      return value ? jsbi_default.BigInt(value).toString() : NO_BALANCE;
                    })["catch"](function() {
                      return NO_BALANCE;
                    }));
                  case 1:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee);
          }))();
        },
        onResult: function onResult(balance2) {
          if (!cancel && balance2 !== lastBalance) {
            lastBalance = balance2;
            onUpdate(balance2);
          }
        }
      };
    }, pollBalanceInterval);
    var stopPollingBalance = pollBalance(account, ethereum, setBalance);
    return function() {
      cancel = true;
      stopPollingBalance();
      setBalance(NO_BALANCE);
    };
  }, [account, ethereum, pollBalanceInterval]);
  return balance;
}
function useWatchBlockNumber(_ref2) {
  var ethereum = _ref2.ethereum, pollBlockNumberInterval = _ref2.pollBlockNumberInterval;
  var lastBlockNumber = (0, import_react2.useRef)(null);
  var blockNumberListeners = (0, import_react2.useRef)(/* @__PURE__ */ new Set());
  var addBlockNumberListener = (0, import_react2.useCallback)(function(cb) {
    if (blockNumberListeners.current.has(cb)) {
      return;
    }
    cb(lastBlockNumber.current);
    blockNumberListeners.current.add(cb);
  }, []);
  var removeBlockNumberListener = (0, import_react2.useCallback)(function(cb) {
    blockNumberListeners.current["delete"](cb);
  }, []);
  var updateBlockNumber = (0, import_react2.useCallback)(function(blockNumber) {
    if (lastBlockNumber.current === blockNumber) {
      return;
    }
    lastBlockNumber.current = blockNumber;
    blockNumberListeners.current.forEach(function(cb) {
      return cb(blockNumber);
    });
  }, []);
  (0, import_react2.useEffect)(function() {
    if (!ethereum) {
      updateBlockNumber(null);
      return;
    }
    var cancel = false;
    var pollBlockNumber = pollEvery(function() {
      return {
        request: function request() {
          return getBlockNumber(ethereum);
        },
        onResult: function onResult(latestBlockNumber) {
          if (!cancel) {
            updateBlockNumber(latestBlockNumber === null ? null : jsbi_default.BigInt(latestBlockNumber).toString());
          }
        }
      };
    }, pollBlockNumberInterval);
    var stopPollingBlockNumber = pollBlockNumber();
    return function() {
      cancel = true;
      stopPollingBlockNumber();
    };
  }, [ethereum, pollBlockNumberInterval, updateBlockNumber]);
  return {
    addBlockNumberListener,
    removeBlockNumberListener
  };
}
function UseWalletProvider(_ref3) {
  var children = _ref3.children, connectorsInitsOrConfigs = _ref3.connectors, pollBalanceInterval = _ref3.pollBalanceInterval, pollBlockNumberInterval = _ref3.pollBlockNumberInterval;
  var walletContext = (0, import_react2.useContext)(UseWalletContext);
  if (walletContext !== null) {
    throw new Error("<UseWalletProvider /> has already been declared.");
  }
  var _useState3 = (0, import_react2.useState)(null), connector = _useState3[0], setConnector = _useState3[1];
  var _useState4 = (0, import_react2.useState)(null), error = _useState4[0], setError = _useState4[1];
  var _useState5 = (0, import_react2.useState)(null), type = _useState5[0], setType = _useState5[1];
  var _useState6 = (0, import_react2.useState)("disconnected"), status = _useState6[0], setStatus = _useState6[1];
  var web3ReactContext = useWeb3React();
  var activationId = (0, import_react2.useRef)(0);
  var account = web3ReactContext.account, chainId = web3ReactContext.chainId, ethereum = web3ReactContext.library, web3Error = web3ReactContext.error;
  var balance = useWalletBalance({
    account,
    ethereum,
    pollBalanceInterval
  });
  var _useWatchBlockNumber = useWatchBlockNumber({
    ethereum,
    pollBlockNumberInterval
  }), addBlockNumberListener = _useWatchBlockNumber.addBlockNumberListener, removeBlockNumberListener = _useWatchBlockNumber.removeBlockNumberListener;
  var connectors = (0, import_react2.useMemo)(function() {
    return getConnectors(connectorsInitsOrConfigs);
  }, [connectorsInitsOrConfigs]);
  var reset = (0, import_react2.useCallback)(function() {
    if (web3ReactContext.active) {
      web3ReactContext.deactivate();
    }
    setConnector(null);
    setError(null);
    setStatus("disconnected");
  }, [web3ReactContext]);
  (0, import_react2.useMemo)(function() {
    if (web3Error instanceof UnsupportedChainIdError) {
      setStatus("error");
      setError(new ChainUnsupportedError(web3Error.message));
    }
  }, [web3Error]);
  var connect = (0, import_react2.useCallback)(function() {
    var _ref4 = _asyncToGenerator(runtime_1.mark(function _callee2(connectorId) {
      var id, _ref5, connectorInit, connectorConfig, connector2, web3ReactConnector, handledError;
      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (connectorId === void 0) {
                connectorId = "injected";
              }
              id = ++activationId.current;
              reset();
              if (!(id !== activationId.current)) {
                _context2.next = 5;
                break;
              }
              return _context2.abrupt("return");
            case 5:
              if (connectors[connectorId]) {
                _context2.next = 9;
                break;
              }
              setStatus("error");
              setError(new ConnectorUnsupportedError(connectorId));
              return _context2.abrupt("return");
            case 9:
              setStatus("connecting");
              _ref5 = connectors[connectorId] || [], connectorInit = _ref5[0], connectorConfig = _ref5[1];
              _context2.next = 13;
              return connectorInit == null ? void 0 : connectorInit();
            case 13:
              connector2 = _context2.sent;
              web3ReactConnector = connector2 == null ? void 0 : connector2.web3ReactConnector == null ? void 0 : connector2.web3ReactConnector(_extends2({}, connectorConfig || {}));
              if (web3ReactConnector) {
                _context2.next = 19;
                break;
              }
              setStatus("error");
              setError(new ConnectorUnsupportedError(connectorId));
              return _context2.abrupt("return");
            case 19:
              _context2.prev = 19;
              setConnector(connectorId);
              _context2.next = 23;
              return web3ReactContext.activate(web3ReactConnector, void 0, true);
            case 23:
              setStatus("connected");
              _context2.next = 41;
              break;
            case 26:
              _context2.prev = 26;
              _context2.t0 = _context2["catch"](19);
              if (!(id !== activationId.current)) {
                _context2.next = 30;
                break;
              }
              return _context2.abrupt("return");
            case 30:
              setConnector(null);
              setStatus("error");
              if (!(_context2.t0 instanceof UnsupportedChainIdError)) {
                _context2.next = 35;
                break;
              }
              setError(new ChainUnsupportedError(_context2.t0.message));
              return _context2.abrupt("return");
            case 35:
              if (!connector2.handleActivationError) {
                _context2.next = 40;
                break;
              }
              handledError = connector2.handleActivationError(_context2.t0);
              if (!handledError) {
                _context2.next = 40;
                break;
              }
              setError(handledError);
              return _context2.abrupt("return");
            case 40:
              setError(_context2.t0);
            case 41:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, null, [[19, 26]]);
    }));
    return function(_x) {
      return _ref4.apply(this, arguments);
    };
  }(), [connectors, reset, web3ReactContext]);
  (0, import_react2.useEffect)(function() {
    if (!account || !ethereum) {
      return;
    }
    var cancel = false;
    setType(null);
    getAccountIsContract(ethereum, account).then(function(isContract) {
      if (!cancel) {
        setStatus("connected");
        setType(isContract ? "contract" : "normal");
      }
    });
    return function() {
      cancel = true;
      setStatus("disconnected");
      setType(null);
    };
  }, [account, ethereum]);
  var wallet = (0, import_react2.useMemo)(function() {
    var _KNOWN_CHAINS$get;
    return {
      _web3ReactContext: web3ReactContext,
      account: account || null,
      balance,
      chainId,
      connect,
      connector,
      connectors,
      error,
      ethereum,
      networkName: chainId ? ((_KNOWN_CHAINS$get = KNOWN_CHAINS.get(chainId)) == null ? void 0 : _KNOWN_CHAINS$get.type) || "unknown" : null,
      providerInfo: connector ? getProviderFromUseWalletId(connector) : getProviderFromUseWalletId("unknown"),
      reset,
      status,
      type
    };
  }, [account, balance, chainId, connect, connector, connectors, error, ethereum, type, reset, status, web3ReactContext]);
  return (0, import_react2.createElement)(UseWalletContext.Provider, {
    value: {
      addBlockNumberListener,
      pollBalanceInterval,
      pollBlockNumberInterval,
      removeBlockNumberListener,
      wallet
    }
  }, children);
}
UseWalletProvider.propTypes = {
  children: import_prop_types.node,
  connectors: (0, import_prop_types.objectOf)(import_prop_types.object),
  pollBalanceInterval: import_prop_types.number,
  pollBlockNumberInterval: import_prop_types.number
};
UseWalletProvider.defaultProps = {
  connectors: {},
  pollBalanceInterval: 2e3,
  pollBlockNumberInterval: 5e3
};
function UseWalletProviderWrapper(props) {
  return (0, import_react2.createElement)(Web3ReactProvider, {
    getLibrary: function getLibrary(ethereum) {
      return ethereum;
    }
  }, (0, import_react2.createElement)(UseWalletProvider, Object.assign({}, props)));
}
UseWalletProviderWrapper.propTypes = UseWalletProvider.propTypes;
UseWalletProviderWrapper.defaultProps = UseWalletProvider.defaultProps;
var esm_default = useWallet;
export {
  ChainUnsupportedError,
  ConnectionRejectedError,
  ConnectorUnsupportedError,
  KNOWN_CHAINS,
  UseWalletProviderWrapper as UseWalletProvider,
  esm_default as default,
  getProviderFromUseWalletId,
  getProviderString,
  useWallet
};
//# sourceMappingURL=use-wallet.js.map
